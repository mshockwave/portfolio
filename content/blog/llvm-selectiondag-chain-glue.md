+++
title = "Control Dependencies in LLVM's SelectionDAG"
date = "2024-12-28"
draft = true
tags = ['llvm', 'compiler-codegen']
+++

SelectionDAG is the data structure used by LLVM's primary instruction selection framework, also known as SelectionDAG ISel. It's a, well, DAG (Direct-Acyclic Graph) where each of the nodes represents an instruction / operation in a basic block; edges between different nodes are either data or control flows.

Similar to LLVM IR, each values in SelectionDAG, called `SDValue`, are also in SSA (Single Static Assignment) form. They're produced by nodes of operations called `SDNode`. With this framework, working with data flows are relatively straightforward. Control flows, or more specifically **control dependencies** between different `SDNode` in the same block, however, can sometimes be a little challenging especially when we want to insert or replace with new nodes that maintain the original, correct control dependencies.

In this very short post, I'm going to talk about how these dependencies are enforced in SelectionDAG and how to deal with them correctly.

As always, let's start with an example:

``` llvm
; File: demo.ll
define i32 @foo(i32 %x, i32 %y) {
  %t0 = mul i32 %x, 7
  %t1 = add i32 %t0, %y
  %cmp = icmp ule i32 %t1, 10
  br i1 %cmp, label %if.then, label %if.else

if.then:                                          ; preds = %entry
  ret i32 94

if.else:                                          ; preds = %entry
  ret i32 %y
}
```

The initial SelectionDAG for snippet above looks like this:

<div style="text-align: center;">
  <picture>
    <source srcset="/images/llvm-sdag-simple-dag.dark.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/llvm-sdag-simple-dag.light.svg">
  </picture>
</div>

{{% details "How to generate this diagram"%}}
This is a GraphViz (*.dot file) diagram generated by the following command:
```
/path/to/llc demo.ll -view-dag-combine1-dags ...
```
If you're on a desktop, this pops up a GUI showing the diagram, should you already installed the proper GraphViz package.

If you don't have a GUI at all (e.g. remote server) that's also fine, it should show up a message like _"Writing '/tmp/dag.foo-fa0c7a.dot'...  done."_ which tells you the location of the *.dot file. Turn it into any of the image format you prefer then you should be good to go:
```
dot -Tsvg /tmp/dag.foo-fa0c7a.dot > dag.foo.dot.svg
```

In addition to `-view-dag-combine1-dags`, which shows the SelectionDAG right before the first DAGCombiner phase, there are also options like `-view-legalize-dags` to dump the DAG at different time points. Feel free to checkout [here](https://github.com/llvm/llvm-project/blob/f590963db836ccbf7c547a3dea9dc719f24444d1/llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp#L154) for these options.
{{% /details %}}

Each of these boxes -- which are `SDNode` we just learned -- more or less represents an instruction in the original IR. There are rows in a box and going from top to bottom, they are operand indices, opcode, result name, and result types. Take the `mul` instruction in the original snippet as an example, it's now represented by a `SDNode` of name `t6`.

Unlike LLVM IR instruction who can only produce a single value as the result, `SDNode` can produce however many `SDValue` results. That's why some of the `SDNode` boxes -- like `CopyFromReg` -- have more than one result types.

The edges that go between different `SDNode`, as we mentioned earlier, are modeling data and control flows. Take a look at the edge between `t6` and `t7`, it corresponds to the use of `%t0` in the original LLVM IR by the `%t1 = add i32 %t0, %y` instruction -- the data flow between these two instructions / `SDNode`. This can also be interpreted as data dependencies as `t6` now always has to execute before `t7`.

By this point, you might already be pondering those dashed red lines sprinkling all over the diagram. Those, are edges that impose control dependencies between two nodes, so that despite the potential lack of data flow between them, the predecessor `SDNode` (the end pointed by the arrow) will always execute before the successor one.

Before we demonstrate the control edges with a concrete example, let switch to another more compact and more commonly used SelectionDAG visualization -- the textual format:

```
Initial selection DAG: %bb.0 'foo:'
SelectionDAG has 17 nodes:
  t0: ch,glue = EntryToken
              t2: i32,ch = CopyFromReg t0, Register:i32 %0
            t6: i32 = mul t2, Constant:i32<7>
            t4: i32,ch = CopyFromReg t0, Register:i32 %1
          t7: i32 = add t6, t4
        t10: i1 = setcc t7, Constant:i32<10>, setule:ch
      t12: i1 = xor t10, Constant:i1<-1>
    t14: ch = brcond t0, t12, BasicBlock:ch<if.else 0x55b3c604fc00>
  t16: ch = br t14, BasicBlock:ch<if.then 0x55b3c604fb00>
```

Readers of my previous [LLVM legalization post](/llvm-codegen-legalization), which showed how to generate this, might find this format familiar[^1].

[^1]: I totally agree that with all the indentations and seemingly random order (sometimes the value definitions don't even appear before the users!) it's not the easiest format to read, but it's still the fastest way to generate _some_ visualization for a SelectionDAG.

Here, we are going to look at `t14` and `t16`.
```
  t14: ch = brcond t0, t12, BasicBlock:ch<if.else 0x55b3c604fc00>
t16: ch = br t14, BasicBlock:ch<if.then 0x55b3c604fb00>
```
`t14` is a conditional branch that jumps to the "false" block, `if.else`, upon its predicate value (`t12`) being true; `t16` is an unconditional branch jumping to the "true" block, `if.then`, for every other cases. It becomes apparent that we always want to put `t14` before `t16`, because otherwise, if we swap these two, the unconditional jump (`t14`) will simply become unreachable and yields an incorrect program.

Therefore, by using the result of `t14` for the first operand of `t16`, we create a control dependency between these two `SDNode` that impose the said constraint. There are two things worth noting here: first, instead of creating a separate mechanism for `SDNode` to express control dependencies, SelectionDAG simply expresses them with edges between a "pseudo" `SDValue` and a `SDNode` operand that uses the value!

This leads to the second notable thing we want to talk here: the _type_ of such pseudo `SDValue`, which is "ch" -- stands for **chain** -- as shown in `t14: ch = brcond ...`. When we want to create a chain `SDValue`, we can use `MVT::Other` as the result type. For instance, to re-create a `brcond` node above:

```c
SDValue BrCond =
    DAG.getNode(/*Opcode*/ISD::BRCOND, DL, /*Result type*/MVT::Other,
                /*Operands*/{InputChain, PredicateVal, FalseBlock});
```

The `DAG` is a `SelectionDAG` instance; all `InputChain` (corresponds to `t0`), `PredicateVal` (corresponds to `t12`), and `FalseBlock` (corresponds to `BasicBlock:ch<if.else 0x55b3c604fc00>`) are `SDValue` instances.

From the name it's not really hard to guess that `InputChain` is also a chain-type value. The idea is that a `SDNode` which produces _and_ consumes chain values can easily form a, well, dependency chain with other `SDNode` alike. That's why most of the chain-producing `SDNode` are also taking chain as one of its operands. 

Of course, a chain-consuming node might not always has a specific predecessor. When that happens, we can simply use a special, always available `SDNode` called `EntryToken`[^2] as the "origin" of the dependency -- which is exactly what `t14` does in this example using `t0`, the `EntryToken` of this DAG, as the input chain (`EntryToken` actually produces two results and we're using the first one here). Please do take note that in this case, input chain is the first operand -- we will circle back to this fact later.

[^2]: You can obtain the `EntryToken` of current DAG via `SelectionDAG::getEntryNode()`.

In addition to applying on branch operations we have just studied briefly, it's pretty common to use chains to impose the ordering between memory operations like loads and stores, as it's a natural fit for constraining side effects, too.
While a chain in SelectionDAG can express _causality_ between two `SDNode` in the absent of any explicit data flow, there is another way to impose an even stronger constraint that puts two `SDNode` right next to each other without any other nodes in between: **glue**.

### Glue

Let's switch to a different example for explaining glue:

```llvm
declare void @bar(i64, i64)

define void @foo(i64 %x, i64 %y) {
  call void @bar(i64 %y, i64 %x)
  ret void
}
```

The LLVM IR snippet above contains a simple function call. The initial SelectionDAG targeting RISC-V looks like this:

```
...
t0: ch,glue = EntryToken
  t7: ch,glue = callseq_start t0, TargetConstant:i64<0>, TargetConstant:i64<0>
  t4: i64,ch = CopyFromReg t0, Register:i64 %1
  t2: i64,ch = CopyFromReg t0, Register:i64 %0
t9: ch,glue = CopyToReg t7, Register:i64 $x10, t4
t11: ch,glue = CopyToReg t9, Register:i64 $x11, t2, t9:1
t14: ch,glue = RISCVISD::CALL t11, TargetGlobalAddress:i64<ptr @bar> 0 [TF=1], Register:i64 $x10, Register:i64 $x11, RegisterMask:Untyped, t11:1
  t15: ch,glue = callseq_end t14, TargetConstant:i64<0>, TargetConstant:i64<0>, t14:1
...
```

Function call in SelectionDAG is a region marked by `callseq_start` and `callseq_end`. The `RISCVISD::CALL` in the middle representing the actual call instruction, surrounded by `SDNode` that do the parameter passings.

Specifically, `t9` copies a 64-bit value from `t4` to `$x10` -- a physical register for carrying the first argument according to RISC-V's calling convention. Likewise, `t11` copies a 64-bit value from `t2` to `$x11` to populate the second function argument.

For these two `CopyToReg` and the actuall `RISCVISD::CALL` node, each of them has an input chain as their first operand (e.g. `t9` is the input chain for `t11`), which effectively prevents them from being reordered -- but this is not enough, we need to further make sure no other `SDNode` can get in between these three nodes. 

Because assuming we allow an unrelated node `t15` to squeeze in between the first and second `CopyToReg` nodes:

```
...
t9: ch,glue = CopyToReg t7, Register:i64 $x10, t4
  t15: i32 = add t4, t2
t11: ch,glue = CopyToReg t9, Register:i64 $x11, t2
t14: ch,glue = RISCVISD::CALL t11, TargetGlobalAddress:i64<ptr @bar> 0 [TF=1], Register:i64 $x10, Register:i64 $x11, RegisterMask:Untyped
...
```

There is a chance that `t15`'s result might eventually be put in physical register `$x10` and incorrectly tampers the value previously populated by `t9`!

To prevent this from happening the easiest way is to leverage the glue values produced by both `t9` and `t11`.

```
t9: ch,glue = CopyToReg t7, Register:i64 $x10, t4
t11: ch,glue = CopyToReg t9, Register:i64 $x11, t2, t9:1
t14: ch,glue = RISCVISD::CALL t11, TargetGlobalAddress:i64<ptr @bar> 0 [TF=1], Register:i64 $x10, Register:i64 $x11, RegisterMask:Untyped, t11:1
```

`CopyToReg` produces a chain and a glue result (recall that a `SDNode` can produce multiple results), and similar to how we create a chain edge, a glue edge is established by using the glue value normally as an operand, like how `t11` uses `t9:1` as its last operand. With glue edges, it's gauranteed that `t9` will always be put _right before_ `t11` and followed by `t14`.
### Glue node and physical register copy