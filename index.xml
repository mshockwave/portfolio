<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Min Hsu's Homepage</title><link>https://myhsu.xyz/</link><description>Recent content on Min Hsu's Homepage</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>min@myhsu.dev (Min-Yih Hsu)</managingEditor><webMaster>min@myhsu.dev (Min-Yih Hsu)</webMaster><copyright>© 2024 Min-Yih Hsu</copyright><lastBuildDate>Sun, 23 Mar 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://myhsu.xyz/index.xml" rel="self" type="application/rss+xml"/><item><title>Calculate Throughput with LLVM's Scheduling Model</title><link>https://myhsu.xyz/llvm-sched-interval-throughput/</link><pubDate>Sun, 23 Mar 2025 00:00:00 +0000</pubDate><author>min@myhsu.dev (Min-Yih Hsu)</author><guid>https://myhsu.xyz/llvm-sched-interval-throughput/</guid><description>From Cambridge Dictionary:
Throughput /ˈθruː.pʊt/ (noun)
an amount of work done in a particular period of time. In architecture-level performance analysis, throughput is usually measured by IPC &amp;ndash; Instruction Per Cycle. The inverse of this property, namely, inverse or reciprocal throughput, is also commonly used to describe the performance characteristics of a sinlge instruction. It&amp;rsquo;s not the time an instruction spends on to finish from start to end &amp;ndash; that is latency &amp;ndash; but more closed to the amount of time it takes to finish a bunch of instructions amortized by their degree of (instruction-level) parallelism.</description><content:encoded><![CDATA[<p>From Cambridge Dictionary:</p>
<blockquote>
<p><strong>Throughput</strong> /ˈθruː.pʊt/ (noun)</p>
<ul>
<li>an amount of work done in a particular period of time.</li>
</ul>
</blockquote>
<p>In architecture-level performance analysis, throughput is usually measured by IPC &ndash; Instruction Per Cycle. The inverse of this property, namely, inverse or reciprocal throughput, is also commonly used to describe the performance characteristics of a sinlge instruction.
It&rsquo;s not the time an instruction spends on to finish from start to end &ndash; that is <em>latency</em> &ndash; but more closed to the amount of time it takes to finish a bunch of instructions amortized by their degree of (instruction-level) <em>parallelism</em>.</p>
<p>LLVM&rsquo;s scheduling model &ndash; which we&rsquo;d covered in <a href="/llvm-sched-model-1">several posts</a> previously &ndash; is a huge database describing the performance characteristics of instructions in a specific processor. While it specifies the instruction latency, a scheduling model does not spells out the inverse throughput of each instruction. We are, however, able to derive this property from other metrics in the model, and this short post is dedicated to show you how to do it.</p>
<h4 id="scheduling-model-in-a-nutshell">Scheduling model in a nutshell</h4>
<p>A scheduling model in LLVM describes an instruction with three primary properties:</p>
<ol>
<li>Latency</li>
<li>Hardware resources it uses</li>
<li>Number of cycles it &ldquo;holds&rdquo; on each of these hardware resources</li>
</ol>
<p>A hardware resource can be thought as an <em>execution pipe</em> in a superscalar processor. Let&rsquo;s say we have an instruction <code>BLAH</code> which uses three pipes, Pipe0 to Pipe2 (<code>P0</code> ~ <code>P2</code>), during its execution. We can describe the number of cycles it holds on each of these three pipes with a pair of numbers: <code>AcquireAtCycle</code> and <code>ReleaseAtCycle</code>.</p>
<p><code>AcquireAtCycle</code> equals to the cycle where <code>BLAH</code> grabs a certain pipe and start working, <strong>relative</strong> to the cycle when instruction was issued, this value is usually zero, meaning this instruction starts using this resource as soon as it was issued &ndash; we&rsquo;ll talk about the scenario where it&rsquo;s NOT (spoiler alert: it has more fun), but right now let&rsquo;s just assume it&rsquo;s always zero; similarly, <code>ReleaseAtCycle</code> is the cycle where <code>BLAH</code> releases this pipe for other instructions to use, also relative to the cycle instruction was issued.</p>
<p>To give a more concrete example, let&rsquo;s say <code>BLAH</code> has the following <code>AcquireAtCycle</code> and <code>ReleaseAtCycle</code> for each of the pipes it uses:</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">AcquireAtCycle</th>
<th style="text-align:center">ReleaseAtCycle</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">P0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">P1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">P2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
<p>We can put it on the timeline like this:</p>
<div style="text-align: center;">
  <picture>
    <source srcset="/images/llvm-sched-interval-throughput-basic.dark.drawio.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/llvm-sched-interval-throughput-basic.light.drawio.svg">
  </picture>
</div>
<p>As you probably also noticed, <code>ReleaseAtCycle</code> is the cycle where a resource had <em>already</em> been released, which means that the time an instruction spends on a certain resource is an interval closed on the left and opened on the right:</p>
<p><code>[AcquireAtCycle, ReleaseAtCycle)</code></p>
<p>Making it easier to calculate the number of cycles in this interval by subtracting these two fields.</p>
<p>If we have two <code>BLAH</code> issued back-to-back:</p>
<div style="text-align: center;">
  <picture>
    <source srcset="/images/llvm-sched-interval-throughput-basic2.dark.drawio.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/llvm-sched-interval-throughput-basic2.light.drawio.svg">
  </picture>
</div>
<p>An instruction is allowed to be issued only if <em>all</em> the hardware resources it needs are available. That&rsquo;s why the second instruction is issued on cycle 3 &ndash; issued at any earlier cycles would result in at least one resource being unavailable.</p>
<p>It is also worth noting that <code>AcquireAtCycle</code> / <code>ReleaseAtCycle</code> only accounts for the time an instruction <strong>exclusively</strong> holds on a single resource<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>. When we say <code>BLAH</code> holds <code>P1</code> for 3 cycles according to the table above, <code>BLAH</code> might take longer than 3 cycles to completely finish the entire instruction &ndash; 3 cycles are just the duration it blocks every other instructions from using <code>P1</code>. After these 3 cycles <code>BLAH</code> might keep running until it finishes. And the time it takes to finish from start to end, is <strong>latency</strong>.</p>
<p>So assuming <code>BLAH</code> has a latency of 5 cycles, this is what it looks like when we zoom into <code>P1</code>:</p>
<div style="text-align: center;">
  <picture>
    <source srcset="/images/llvm-sched-interval-throughput-ilp.dark.drawio.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/llvm-sched-interval-throughput-ilp.light.drawio.svg">
  </picture>
</div>
<p>Each row is an instruction in this diagram. Boxes with solid edges are the duration <code>BLAH</code> holds onto <code>P1</code>; dashed boxes mark the extra time <code>BLAH</code> spends on to actually finish. As you can see, the combined duration of solid and dashed boxes is equal to the latency of <code>BLAH</code> &ndash; 5 cycles.</p>
<p>Pretty straightforward, right? Now let&rsquo;s see how to calculate the (inverse) throughput in this scenario.</p>
<h4 id="basic-throughput-calculation">Basic throughput calculation</h4>
<p>Earlier we mentioned that inverse throughput is the time to execute a group of instructions amortized by their degree of instruction-level parallelism. On the hind sight, it sounds like we need to know how long it takes to run <code>N</code> instructions, and divided by the number of instructions on the fly in this duration &ndash; which are both something compiler cannot easily figure out statically.</p>
<p>But in reality, it&rsquo;s actually pretty easy to know the throughput with <code>ReleaseAtCycle</code>. Recall the diagram we just saw, but increase the number of instructions on the fly:</p>
<div style="text-align: center;">
  <picture>
    <source srcset="/images/llvm-sched-interval-throughput-ilp2.dark.drawio.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/llvm-sched-interval-throughput-ilp2.light.drawio.svg">
  </picture>
</div>
<p>The total number of cycles it takes to finish these instructions is <code>ReleaseAtCycle x N + (Latency - ReleaseAtCycle)</code> (or <code>ReleaseAtCycle x (N - 1) + Latency</code> if you prefer), where <code>N</code> is the number of instructions we see here, which means we&rsquo;re going to spend <code>3 x 4 + (5 - 3)</code>, 14 cycles in total.</p>
<p>If we increase the value of <code>N</code> to, let&rsquo;s say <em>infinity</em>, then <code>(Latency - ReleaseAtCycle)</code> &ndash; which is a constant &ndash; will actually become really insignificant! What actually dominates the total number of cycles becomes <code>ReleaseAtCycle x N</code>.
So eventually, the inverse throughput with regards to this particular resource, <code>P1</code>, equals to <code>ReleaseAtCycle x N / N = ReleaseAtCycle</code>.</p>
<p>But hold on a second what about <em>other</em> resources like <code>P0</code> and <code>P2</code>? Applying the same diagram on these two pipes and you&rsquo;ll find out their total time to finish <code>N</code> instructions are shorter than 14 cycles imposed by <code>P1</code>. Meaning <code>P1</code>&rsquo;s total time dominates the inverse throughput of this instruction, making other two&rsquo;s insignificant (even they finish ealier, they have to wait for <code>P1</code>). And this is caused by the fact that <code>P1</code> has the <em>largest</em> <code>ReleaseAtCycle</code>, which finally leads to a neat formula for calculating inverse throughput of the <strong>entire instruction</strong>:</p>






<pre tabindex="0"><code>max(ReleaseAtCycle_0, ReleaseAtCycle_1, ..., ReleaseAtCycle_N)</code></pre>
<p>or</p>






<pre tabindex="0"><code>max(ReleaseAtCycles)</code></pre>
<p>This formula is also what <code>MCSchedModel::getReciprocalThroughput</code> <a href="https://github.com/llvm/llvm-project/blob/616737c386776b0cfbda888a4d52e6036ccf1af8/llvm/lib/MC/MCSchedule.cpp#L107">uses</a> to calculate the inverse throughput of an instruction &ndash; modulo some differences like accounting for number of units of a resource<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>, which we assume it to be one in our discussions.</p>
<p>Now, I won&rsquo;t spend hours wrestling with grammar, go all the way around to <strong>just</strong> write a blog post about something you can look up from code in a couple of minutes &ndash; the things we&rsquo;ve discussed so far are just a prelude to the <strong><em>fun</em></strong> part:</p>
<p>How to calculate throughput when <code>AcquireAtCycle</code> is not zero.</p>
<h4 id="calculating-throughput-with-resource-segments">Calculating throughput with resource segments</h4>
<p>Let&rsquo;s look at another instruction, <code>BLOB</code>, with the following <code>AcquireAtCycle</code> and <code>ReleaseAtCycle</code> numbers on <code>P0</code> ~ <code>P2</code>:</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">AcquireAtCycle</th>
<th style="text-align:center">ReleaseAtCycle</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">P0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">P1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">P2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
</tr>
</tbody>
</table>
<p>When <code>AcquireAtCycle</code> is greater than zero, the instruction will not seize this resource right after being issued, but until another <code>AcquireAtCycle</code> cycles later. Which means the duration <code>BLOB</code> holds on each resources &ndash; also known as <strong>resource segments</strong> &ndash; now looks like:</p>
<div style="text-align: center;">
  <picture>
    <source srcset="/images/llvm-sched-interval-throughput-segment.dark.drawio.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/llvm-sched-interval-throughput-segment.light.drawio.svg">
  </picture>
</div>
<p>The biggest implication of having non-zero <code>AcquireAtCycle</code> is that the <em>second</em> <code>BLOB</code> instruction that comes after will be issued and arranged like this:</p>
<div style="text-align: center;">
  <picture>
    <source srcset="/images/llvm-sched-interval-throughput-segment2.dark.drawio.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/llvm-sched-interval-throughput-segment2.light.drawio.svg">
  </picture>
</div>
<p>Meaning, we can issue the second <code>BLOB</code> as early as cycle 3 &ndash; as opposed to cycle 5 when all of the <code>AcquireAtCycle</code> are zero. It&rsquo;s safe to &ldquo;run ahead&rdquo; and issue early because although <code>BLOB</code> seizes <code>P0</code> right away, there is a slack before it tries to acquire <code>P1</code> and <code>P2</code> a few cycles later.</p>
<p>This is how an instructions with resource segments is scheduled. Now, how do we calculate its inverse throughput?</p>
<p>There are several insights we learned about calculating inverse throughput of non-resource-segment instructions from the previous section:</p>
<ul>
<li>Compared to <code>ReleaseAtCycle</code> (and <code>AcquireAtCycle</code>), latency doesn&rsquo;t really matter &ndash; it&rsquo;ll eventually be a single constant appended at the end of the formula that can be ignored when number of instructions (i.e. <code>N</code>) is approaching infinity</li>
<li>The whole calculation can be simplified to dividing the cycle at which the last instruction releases the last resource &ndash; or the <em>right-most</em> cycle, which is cycle 7 in the last diagram &ndash; by <code>N</code>. For non-resource-segment instructions, the right-most cycle is always <code>max(ReleaseAtCycles) x N</code></li>
</ul>
<p>So our task can really boil down to finding the right-most cycle here.
Looking at the last diagram, we might considering using <code>max(ReleaseAtCycles) x N</code> as the right-most cycle for instructions with resource segments here again.</p>
<p>Because first, the resource with <code>max(ReleaseAtCycles)</code> &ndash; <code>P1</code> in this case &ndash; will always be the resource where right-most cycle happens. Now the question would be the quantity of this right-most cycle: <em>Intuitively</em>, resource with <code>max(ReleaseAtCycles)</code> will always be the one that concatenates with its counterpart in the next instruction, back to back, without any &ldquo;gap&rdquo; in between. So the quantity of right-most cycle can be easily calculated as <code>max(ReleaseAtCycles) x N</code>.</p>
<p>As you might have noticed, having no gap is an important prerequisite here, otherwise if there is a gap, it will becomes part of the <em>recurring</em> factor. Namely, the right-most cycle will be something like <code>(max(ReleaseAtCycles) + C) x N</code> where <code>C</code> is a constant factor of gap.</p>
<p>But is it always the case for resources with <code>max(ReleaseAtCycles)</code> to have no gaps in between?</p>
<p>Sadly, here is a counter example:</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">AcquireAtCycle</th>
<th style="text-align:center">ReleaseAtCycle</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">P0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">P1</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">P2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">4</td>
</tr>
</tbody>
</table>
<div style="text-align: center;">
  <picture>
    <source srcset="/images/llvm-sched-interval-throughput-segment3.dark.drawio.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/llvm-sched-interval-throughput-segment3.light.drawio.svg">
  </picture>
</div>
<p>There is still a silver lining in this though: regardless of gap, the resource with <code>max(ReleaseAtCycles)</code> is still the resource where right-most cycle happens &ndash; as we can observe from this counter example as well. So if we can figure out <code>C</code> &ndash; the constant factor of gap &ndash; then we still can calculate the inverse throughput in terms of <code>max(ReleaseAtCycles)</code>.</p>
<p>For that, let&rsquo;s play a liiiitle bit of jigsaw puzzle.</p>
<p>Let&rsquo;s step back a little bit and think about how we placed our second instruction in the first place which eventually led to the last diagram: starting from cycle 0, we effectively &ldquo;shift&rdquo; the second instruction right by <code>M</code> cycles, so far beyond that there is no overlap between the two instructions.</p>
<div style="text-align: center;">
  <picture>
    <source srcset="/images/llvm-sched-interval-throughput-segment4.dark.drawio.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/llvm-sched-interval-throughput-segment4.light.drawio.svg">
  </picture>
</div>
<p>Then, we shift the second instruction left by <code>D</code> until one of the resources <em>touches</em> its counterpart in the first instruction.</p>
<div style="text-align: center;">
  <picture>
    <source srcset="/images/llvm-sched-interval-throughput-segment4-2.dark.drawio.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/llvm-sched-interval-throughput-segment4-2.light.drawio.svg">
  </picture>
</div>
<p>To simplify, we can set <code>M</code>, the right shift amount, to be <code>max(ReleaseAtCycles)</code> (<code>R_max</code> in the diagram below):</p>
<div style="text-align: center;">
  <picture>
    <source srcset="/images/llvm-sched-interval-throughput-segment4-3.dark.drawio.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/llvm-sched-interval-throughput-segment4-3.light.drawio.svg">
  </picture>
</div>
<p>With <code>M = max(ReleaseAtCycles)</code>, the distance between the right edges of both <code>P1</code> boxes becomes <code>max(ReleaseAtCycles) - D</code> after we shift the second instruction left by <code>D</code>:</p>
<div style="text-align: center;">
  <picture>
    <source srcset="/images/llvm-sched-interval-throughput-segment4-4.dark.drawio.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/llvm-sched-interval-throughput-segment4-4.light.drawio.svg">
  </picture>
</div>
<p>This distance, <code>max(ReleaseAtCycles) - D</code>, is especially important because it&rsquo;s the recurring factor <code>max(ReleaseAtCycles) + C</code> mentioned earlier (i.e. <code>C = -D</code>). In other words, the right-most cycle we&rsquo;ve been looking for is equal to <code>(max(ReleaseAtCycles) - D) x N</code> when <code>N</code> is sufficiently big:</p>
<div style="text-align: center;">
  <picture>
    <source srcset="/images/llvm-sched-interval-throughput-segment4-5.dark.drawio.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/llvm-sched-interval-throughput-segment4-5.light.drawio.svg">
  </picture>
</div>
<p>So now we only have one thing left: finding the value of <code>D</code>.</p>
<p>During the left shifting, if we look at each hardware resource in the second instruction <em>individually</em>, each of them needs to move a different distance before touching their counterpart in the first instruction. Using the last setup as example, <code>P0</code> needs to shift 3 cycles left, 4 cycles for <code>P1</code>, and 2 cycles for <code>P2</code>. The value of <code>D</code> would be the minimum among them (i.e. <code>D = 2</code>). Furthermore, the individual shifting amount can be expressed as</p>






<pre tabindex="0"><code>(AcquireAtCycle + M) - ReleaseAtCycle</code></pre>
<p>Because <code>AcquireAtCycle + M</code> is effectively the &ldquo;new&rdquo; <code>AcquireAtCycle</code> after we shift it right by <code>M</code>, and subtracting it with <code>ReleaseAtCycle</code> (of the first instruction), would give you the distance to close up.</p>
<p>Therefore:</p>






<pre tabindex="0"><code>D = min((AcquireAtCycle_i + M) - ReleaseAtCycle_i), ∀ i = P0 ~ P2
  = min(M - (ReleaseAtCycle_i - AcquireAtCycle_i))</code></pre>
<p>Because <code>M</code> is constant, to get the minimum of <code>M - (ReleaseAtCycle_i - AcquireAtCycle_i)</code> we need the largest <code>ReleaseAtCycle_i - AcquireAtCycle_i</code>&hellip;which is the interval / segment with <strong>longest</strong> length! (i.e. <code>i = P2</code> in this case)</p>
<p>But let&rsquo;s not stop here: because <code>M = max(ReleaseAtCycles)</code>, the recurring factor becomes&hellip;</p>






<pre tabindex="0"><code>  max(ReleaseAtCycles) - D
= max(ReleaseAtCycles) - M + (ReleaseAtCycle_i - AcquireAtCycle_i), i = P2
= ReleaseAtCycle_i - AcquireAtCycle_i, i = P2</code></pre>
<p>Which makes the right-most cycle (of all <code>N</code> instructions) we&rsquo;ve been looking for equals to:</p>






<pre tabindex="0"><code>(ReleaseAtCycle_i - AcquireAtCycle_i) x N, i = P2</code></pre>
<p>As it turns out, the inverse throughput of <code>N</code> instructions with resource segments &ndash; right-most cycle divided by <code>N</code> &ndash; simply equals<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup> to the <strong>longest</strong> segment length among all hardware resources!</p>






<pre tabindex="0"><code>Inverse throughput =
  max(ReleaseAtCycle_i - AcquireAtCycle_i), ∀ i = hardware resources</code></pre>
<p>This formula also covers both the basic cases from section 2 and cases with resource segments.</p>
<h4 id="discussions">Discussions</h4>
<p>Here is a little background of why I wrote this post: at the time of writing, <code>MCSchedModel::getReciprocalThroughput</code> doesn&rsquo;t handle <code>AcquireAtCycle</code> at all, this <a href="https://github.com/llvm/llvm-project/pull/130574#discussion_r2005110229">comment</a> from a code review raised a question on how to calculate it, which nerd-sniped me and as a consequence, this post.</p>
<p>In that thread, <a href="https://github.com/jvillette38">@jvillette38</a> also proposed using longest resource segment as inverse throughput. However, it was slightly counter-intuitive to me at that time as inverse throughput should be calculated from the right-most cycle of all <code>N</code> instructions, yet is the resource with the longest segment <em>always</em> be the one where right-most cycle happens? And in general, what&rsquo;s the connection between the longest segment length and the right-most cycle?</p>
<p>We&rsquo;ve shown the answer of the first question to be &ldquo;No&rdquo;. Though as it turns out, inverse throughput is still dominated by the longest segment. I think this can partially be explained by  <code>D</code>&rsquo;s formula, which suggests that the longest hardware resource segment in the second instruction is always the first to touch its counterpart in the first instruction during left shifting, with <strong>no gap</strong> in between. Implying that the total length (i.e total cycles) is equal or larger than the longest segment length times <code>N</code>. And in the case where resource with the longest segment is not where right-most cycle happens, the &ldquo;delta&rdquo; between the release cycle of <em>last</em> longest segment and the actual right-most cycle will just be a constant which we can happily ignore when <code>N</code> is sufficiently large.</p>
<p>Anyway, I hope I&rsquo;m not overthinking this whole time 😛 and I hope this post provides a stronger argument on using largest segment length as inverse throughput.</p>
<h3 id="comments">Comments</h3>
<p>Feel free to leave comments at <a href="https://github.com/mshockwave/portfolio/discussions/12">https://github.com/mshockwave/portfolio/discussions/12</a></p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>This is why metrics like <code>AcquireAtCycle</code> / <code>ReleaseAtCycle</code> sometimes are also called <strong>occupancy</strong> &ndash; the number of cycles it occupies a resource.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>We covered this concept in <a href="/llvm-sched-model-1.5/">here</a>.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>Again, assuming number of units in each resource is equal to 1. If it&rsquo;s greater than 1, then the inverse throughput should be further divided by the number of units.&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded></item><item><title>Visualize RISC-V Vector Memory Instructions</title><link>https://myhsu.xyz/riscv-rvv-mem-visualize/</link><pubDate>Sun, 05 Jan 2025 00:00:00 +0000</pubDate><author>min@myhsu.dev (Min-Yih Hsu)</author><guid>https://myhsu.xyz/riscv-rvv-mem-visualize/</guid><description>RISC-V Vector (RVV) extension has several kinds of load / store instructions which access memory in different ways. Just as the memory access pattern might take a little more time to fully understand, it gets even more tricky when multiplexing with RVV&amp;rsquo;s own concepts like variable element size (SEW), register groups (LMUL), number of elements (VL), masks and mask / tail policies.
Personally I found it easier to memorize them with visualization, hence this (relatively) short post!</description><content:encoded><![CDATA[<p>RISC-V Vector (RVV) extension has several kinds of load / store instructions which access memory in different ways. Just as the memory access pattern might take a little more time to fully understand, it gets even more tricky when multiplexing with RVV&rsquo;s own concepts like variable element size (SEW), register groups (LMUL), number of elements (VL), masks and mask / tail policies.</p>
<p>Personally I found it easier to memorize them with visualization, hence this (relatively) short post!</p>
<p>The following content is going to put these instructions in two main categories by their memory access patterns: <em>strided</em> and <em>segmented</em> access. Each of them can be further divided into several sub categories.
We also assume <code>VLEN</code> &ndash; the size of a single vector register &ndash; to be 128 bits. And since RVV store instructions work nearly the same way as loads except going to other direction from registers to memory, we&rsquo;re only discussing load instructions here.</p>
<p>Without further ado, let&rsquo;s get started!</p>
<h3 id="strided-access">Strided access</h3>
<p>Strided memory access is meant to read individual elements from the memory into a <em>single</em> vector register group. The sub variants of this mainly differ in how the &ldquo;gap&rdquo; between two in-memory elements is determined (or whether there is a gap at all).</p>
<h4 id="unit-stride">Unit-stride</h4>
<p>Consider this snippet:</p>






<pre tabindex="0"><code>vsetvli  zero, zero, e32, m4
vle32.v  v4, (a0)</code></pre>
<p>We&rsquo;re loading a <em>continuous</em> (meaning, no gap between two elements) chunk of data starting from the memory address pointed by <code>a0</code>.</p>
<p>This is the diagram for it:</p>
<div style="text-align: center; min-width: 50vw;">
  <picture>
    <source srcset="/images/riscv-unit-stride-load.dark.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/riscv-unit-stride-load.light.svg">
  </picture>
</div>
<p>Here, I would like to spend some time on an important concept called <strong>effective</strong> LMUL and SEW, or <em>EMUL</em> and <em>EEW</em>, respectively. Normally, we use VSETVL instructions, like <code>vsetvli</code> shown above, to select the current LMUL (register grouping) and SEW (element width) settings.</p>
<p>But case like the unit stride load we&rsquo;re discussing here uses their <em>own</em> element width setting that is directly encoded into the opcode. And such element width setting, the one they actually use, is called EEW &ndash; effective element width.</p>
<p>For unit stride load, EEW is placed in the opcode with this format: <code>vle&lt;eew&gt;.v</code>. So regardless of what <code>vsetvli</code> instruction right before it says, <code>vle32.v</code> always loads 32-bit elements from the memory.</p>
<p>But does that means we can ignore the SEW setting specified in the <code>vsetvli</code> instruction above? It turns out we cannot, because if the SEW (by <code>vsetvli</code>) is different from EEW (by <code>vle32.v</code>), we have to <em>scale</em> the register grouping (LMUL) as well! The scaled register grouping &ndash; effective LMUL or <em>EMUL</em> &ndash; is the one we actually use, and it&rsquo;s calculated by</p>






<pre tabindex="0"><code>EMUL = (EEW / SEW) * LMUL</code></pre>
<p>To give a concrete example, considered the following snippet:</p>






<pre tabindex="0"><code>vsetvli  zero, zero, e32, m4
vle64.v  v4, (a0)</code></pre>
<p>EEW (e64) now differs from SEW (e32). Therefore, while it loads 64-bit elements from memory, the register grouping it actually uses (i.e. EMUL) is now 8, because <code>EMUL = (e64 / e32) * 4</code>.</p>
<p>The idea of scaling LMUL is to make sure <code>VLMAX</code> &ndash; the maximum number of elements we can process, or the maximum <code>VL</code> value &ndash; stays the same.</p>
<h4 id="strided">Strided</h4>
<p>For this, we&rsquo;re loading a stream of data in which elements are apart from each other in the memory by a certain distance or, <em>stride</em>.</p>






<pre tabindex="0"><code>li  t0, 8
vsetvli  zero, zero, e32, m4
vlse32.v  v4, (a0), t0</code></pre>
<p>For instance, the snippet above loads the next element 8 bytes away from the starting address of the current element. Here is how it looks like:</p>
<br>
<div style="text-align: center; min-width: 45vw;">
  <picture>
    <source srcset="/images/riscv-stride-load.dark.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/riscv-stride-load.light.svg">
  </picture>
</div>
<p>In this diagram, &ldquo;Stride&rdquo; is equal to 8, which is designated by <code>t0</code> in the original snippet.</p>
<p>It&rsquo;s worth noting that <code>VL</code> is still describing the total number of elements we want to load, or number of elements in the destination vector register group, rather than the &ldquo;total range&rdquo; of EEW-size elements on the memory. Same logic goes to the mask: it&rsquo;s applying on the vector register group rather on the memory.</p>
<h4 id="indexed">Indexed</h4>
<p>What if we don&rsquo;t want a <em>single</em> constant stride, but different &ldquo;strides&rdquo; for each elements?
Allow me to introduce the indexed scheme, where the memory address offset &ndash; or index value &ndash; for each element is specified by yet another vector register group.</p>






<pre tabindex="0"><code>vsetvli  zero, zero, e32, m4
vluxei32.v  v4, (a0), v0</code></pre>
<p>Here, the register group started with <code>v0</code> contains the offset values (in bytes) for each element it wants to load. This is how it looks:</p>
<br>
<div style="text-align: center; min-width: 50vw;">
  <picture>
    <source srcset="/images/riscv-index-load.dark.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/riscv-index-load.light.svg">
  </picture>
</div>
<p>With a new vector register group as indices come into play, indexed load has a slightly different rule regarding EEW and EMUL. The element width encoded in the opcode &ndash; 32 bits in the case of <code>vluxei32</code> &ndash; becomes EEW for the <em>index</em> register group, which consequently uses the scaled register grouping factor as its EMUL.
On the other hand, the data register group now uses SEW and LMUL specified by <code>vsetvli</code> as their element width and register grouping factor!</p>
<p>As shown in the diagram, these offset values from the index register group are always applied relative to the starting address &ndash; the one pointed by <code>a0</code> &ndash; rather than being relative to the address of the previous element.</p>
<p>Another thing worth noting is that the instruction we used, <code>vluxei32.v</code>, accesses elements on memory in <em>arbitrary</em> order, just like unit-stride and constant-stride loads. RVV, however, does provide another variant of indexed load, <code>vloxei32.v</code>, that accesses memory in-order.</p>
<h3 id="segmented-access">Segmented access</h3>
<p>Rather than dealing with individual in-memory elements, segmented memory access pattern reads a larger chunk of memory &ndash; namely, a segment &ndash; at a time and distributes the content of a segment into <em>multiple</em> vector register groups.</p>
<p>It is designed for scenarios where there is an array of objects on memory, for instance:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#cba6f7">struct</span> <span style="color:#f9e2af">Point</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>  <span style="color:#f38ba8">uint32_t</span> X;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>  <span style="color:#f38ba8">uint32_t</span> Y;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">4</span><span>};
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">5</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">6</span><span>Point the_array[<span style="color:#fab387">100</span>];</span></span></code></pre></div>
<p>We want to read <code>the_array</code> from memory <em>and</em> effectively turn it into something like this:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#6c7086;font-style:italic">// Note: this is just a pseudo code.
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#cba6f7">struct</span> <span style="color:#f9e2af">NewPoint</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>  <span style="color:#f38ba8">uint32_t</span> X[<span style="color:#fab387">100</span>]; <span style="color:#6c7086;font-style:italic">// A vector register group.
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">4</span><span><span style="color:#6c7086;font-style:italic"></span>  <span style="color:#f38ba8">uint32_t</span> Y[<span style="color:#fab387">100</span>]; <span style="color:#6c7086;font-style:italic">// The other vector register group.
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">5</span><span><span style="color:#6c7086;font-style:italic"></span>};
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">6</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">7</span><span>NewPoint the_array_new;</span></span></code></pre></div>
<p>Where we use a vector register group to store all the <code>X</code> values, and use the other vector register group for <code>Y</code>.</p>
<p>In this case, <code>struct Point</code> is considered a <strong>segment</strong> with two <em>fields</em> (i.e. <code>X</code> and <code>Y</code>). A segment is also known as a &ldquo;sub-array&rdquo;, which means that individual fields in a segment need to have the <em>same</em> data width. Therefore, this is NOT a segment:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#cba6f7">struct</span> <span style="color:#f9e2af">Foo</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>  <span style="color:#f38ba8">uint16_t</span> A;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>  <span style="color:#f38ba8">uint32_t</span> B;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">4</span><span>};</span></span></code></pre></div>
<p>For the following content, let&rsquo;s use <code>struct Point</code> as the segment.</p>
<h4 id="unit-stride-segmented">Unit-stride segmented</h4>
<p>Unit segmented load encodes the number of fields (NF) along with EEW in its opcode: <code>vlseg&lt;NF&gt;e&lt;EEW&gt;.v</code>.</p>
<p>Take following snippet as an example:</p>






<pre tabindex="0"><code>vsetvli  zero, zero, e32, m4
vlseg2e32.v  v4, (a0)</code></pre>
<p>It&rsquo;s loading a <em>continuous</em> sequence of two-field segments starting with the memory address pointed by <code>a0</code>. Here is the diagram:</p>
<br>
<div style="text-align: center; min-width: 60vw;">
  <picture>
    <source srcset="/images/riscv-unit-segmented-load.dark.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/riscv-unit-segmented-load.light.svg">
  </picture>
</div>
<p>The most unique aspect here is of course how it deals with individual fields in a segment: in principle, values from the same field is store in a single vector register group.</p>
<p>The destination register group specified in the assembly instruction, <code>v4</code> in this case, tells the register group (i.e. <code>v4</code> ~ <code>v7</code>) for the first field. The next field will be stored in the <em>following</em> register group (i.e. <code>v8</code> ~ <code>v11</code>), and so on and so forth.</p>
<p>So if we have something like <code>vlseg3e32.v  v4, (a0)</code> with EMUL = 2, a total of three vector register groups will be touched:  <code>v4</code> ~ <code>v5</code>, <code>v6</code> ~ <code>v7</code>, and <code>v8</code> ~ <code>v9</code>.</p>
<p>Similar to strided and indexed loads mentioned earlier, <code>VL</code> and mask are applied on each of the (destination) vector register groups, rather than applying on the memory.</p>
<h4 id="strided-segmented">Strided segmented</h4>
<p>This is the segmented version of strided load we&rsquo;d seen earlier.</p>






<pre tabindex="0"><code>li  t0, 16
vsetvli  zero, zero, e32, m4
vlsseg2e32.v  v4, (a0), t0</code></pre>
<br>
<div style="text-align: center; min-width: 50vw;">
  <picture>
    <source srcset="/images/riscv-stride-segmented-load.dark.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/riscv-stride-segmented-load.light.svg">
  </picture>
</div>
<p>The start address of the next segment is equal to that of the current segment plus stride.</p>
<h4 id="indexed-segmented">Indexed segmented</h4>
<p>Finally, indexed segmented is, you guess, the segmented version of indexed load! (duh&hellip;)</p>






<pre tabindex="0"><code>vsetvli  zero, zero, e32, m4
vluxseg2ei32.v  v4, (a0), v0</code></pre>
<br>
<div style="text-align: center; min-width: 60vw;">
  <picture>
    <source srcset="/images/riscv-index-segmented-load.dark.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/riscv-index-segmented-load.light.svg">
  </picture>
</div>
<p>Again, the offset values are always relative to the starting address (in this case, value of <code>a0</code>) rather than being relative to the address of the previous segment.</p>
<p>Similar to indexed load, <code>vluxseg</code> accesses memory in arbitrary order while <code>vloxseg</code> being its ordered variant. The EEW encoded in the opcode is for the index register group while all the data register groups are using SEW and LMUL.</p>
<hr>
<p>And that&rsquo;s pretty much it! Once we categorized in this way it&rsquo;s actually not so hard to understand. Segmented access might look daunting at first glance, but once you&rsquo;re familiar with segments, rest of the concepts can just be carried over from their strided access counterparts.</p>
<h3 id="comments">Comments</h3>
<p>Feel free to leave comments at <a href="https://github.com/mshockwave/portfolio/discussions/8">https://github.com/mshockwave/portfolio/discussions/8</a></p>
<p>Any feedback is much appreciated!</p>
]]></content:encoded></item><item><title>Scheduling Model in LLVM - Part II</title><link>https://myhsu.xyz/llvm-sched-model-1.5/</link><pubDate>Mon, 28 Oct 2024 00:00:00 +0000</pubDate><author>min@myhsu.dev (Min-Yih Hsu)</author><guid>https://myhsu.xyz/llvm-sched-model-1.5/</guid><description>In the previous post, we covered the basics of scheduling model in LLVM. Specifically, per-operand tokens that connect an instruction with models that spell out processor-specific scheduling properties like instruction latency, and the concept of processor resources with different sizes of buffer.
While I was planning to write how scheduling models are used in this post &amp;ndash; namely, covering things like instruction scheduler and MCA &amp;ndash; the draft was overwhelmed by the sheer amount of content needed to cover just the substrate.</description><content:encoded><![CDATA[<p>In the <a href="/llvm-sched-model-1">previous post</a>, we covered the basics of scheduling model in LLVM. Specifically, per-operand tokens that connect an instruction with models that spell out processor-specific scheduling properties like instruction latency, and the concept of processor resources with different sizes of buffer.</p>
<p>While I <em>was</em> planning to write how scheduling models are used in this post &ndash; namely, covering things like instruction scheduler and MCA &ndash; the draft was overwhelmed by the sheer amount of content needed to cover just the substrate. In addition, I found that I missed some more advanced yet commonly used constructions in the previous post. So if you&rsquo;ll excuse me, I&rsquo;d like to procrastinate writing about MachineScheduler and MCA, leaving it for future Min to worry, and dive into three important scheduling model constructions in this post: number of <code>ProcResource</code> units, <code>ProcResGroup</code>, and super resource.</p>
<p>These three horsemen together enable scheduling models to express <strong>hierarchy</strong> structure &ndash; a concept that we have only scratched the surface previously. Modern microarchitectures often employ complicated processor resource distributions and groupings, like having multiple execution pipes with asymmetric capabilities. It is of paramount importance to express those structures with the things we&rsquo;re about to cover.
Without further ado, let&rsquo;s start with the number of <code>ProcResource</code> units!</p>
<h3 id="number-of-units-in-a-procresource">Number of units in a ProcResource</h3>
<p>So far we&rsquo;ve mentioned things like <code>ProcResource&lt;1&gt;</code> or <code>ProcResource&lt;2&gt;</code> several times without explaining the numbers in the template argument list. That specific argument stands for the <strong>number of units</strong> in a processor resource.</p>
<p>This property is directly related to the <em>throughput</em> of this resource, namely, how many uops it can process in a given time. To give you a more concrete example, let&rsquo;s see how LLVM&rsquo;s scheduling model calculates the <strong>reciprocal throughput</strong> &ndash; a synonym of <em>inverse</em> throughput &ndash; of an instruction.</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 1</span><span>std<span style="color:#89dceb;font-weight:bold">::</span>optional<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#f38ba8">double</span><span style="color:#89dceb;font-weight:bold">&gt;</span> Throughput;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 2</span><span><span style="color:#cba6f7">const</span> MCSchedModel <span style="color:#89dceb;font-weight:bold">&amp;</span>SM <span style="color:#89dceb;font-weight:bold">=</span> STI.getSchedModel();
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 3</span><span><span style="color:#cba6f7">const</span> MCWriteProcResEntry <span style="color:#89dceb;font-weight:bold">*</span>I <span style="color:#89dceb;font-weight:bold">=</span> STI.getWriteProcResBegin(<span style="color:#89dceb;font-weight:bold">&amp;</span>SCDesc);
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 4</span><span><span style="color:#cba6f7">const</span> MCWriteProcResEntry <span style="color:#89dceb;font-weight:bold">*</span>E <span style="color:#89dceb;font-weight:bold">=</span> STI.getWriteProcResEnd(<span style="color:#89dceb;font-weight:bold">&amp;</span>SCDesc);
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 5</span><span><span style="color:#cba6f7">for</span> (; I <span style="color:#89dceb;font-weight:bold">!=</span> E; <span style="color:#89dceb;font-weight:bold">++</span>I) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 6</span><span>  <span style="color:#cba6f7">if</span> (<span style="color:#89dceb;font-weight:bold">!</span>I<span style="color:#89dceb;font-weight:bold">-&gt;</span>ReleaseAtCycle)
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 7</span><span>    <span style="color:#cba6f7">continue</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 8</span><span>  <span style="color:#f38ba8">unsigned</span> NumUnits <span style="color:#89dceb;font-weight:bold">=</span> SM.getProcResource(I<span style="color:#89dceb;font-weight:bold">-&gt;</span>ProcResourceIdx)<span style="color:#89dceb;font-weight:bold">-&gt;</span>NumUnits;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 9</span><span>  <span style="color:#f38ba8">double</span> Temp <span style="color:#89dceb;font-weight:bold">=</span> NumUnits <span style="color:#89dceb;font-weight:bold">*</span> <span style="color:#fab387">1.0</span> <span style="color:#89dceb;font-weight:bold">/</span> I<span style="color:#89dceb;font-weight:bold">-&gt;</span>ReleaseAtCycle;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">10</span><span>  Throughput <span style="color:#89dceb;font-weight:bold">=</span> Throughput <span style="color:#89dceb;font-weight:bold">?</span> std<span style="color:#89dceb;font-weight:bold">::</span>min(<span style="color:#89dceb;font-weight:bold">*</span>Throughput, Temp) <span style="color:#89dceb;font-weight:bold">:</span> Temp;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">11</span><span>}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">12</span><span><span style="color:#cba6f7">if</span> (Throughput)
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">13</span><span>  <span style="color:#cba6f7">return</span> <span style="color:#fab387">1.0</span> <span style="color:#89dceb;font-weight:bold">/</span> <span style="color:#89dceb;font-weight:bold">*</span>Throughput;</span></span></code></pre></div>
<p>The code above is <a href="https://github.com/llvm/llvm-project/blob/c2717a89b8437d041d532c7b2c535ca4f4b35872/llvm/lib/MC/MCSchedule.cpp#L90">excerpted</a> from <code>MCSchedModel::getReciprocalThroughput</code>: it scans through every write resources in this instruction (represented by its scheduling class, <code>SCDesc</code>) via each resource&rsquo;s index <code>ProcResourceIdx</code>.
The throughput contributed by each resource used by this instruction is calculated by dividing the number of units (<code>NumUnits</code>) by <code>ReleaseAtCycle</code>, which is the number of cycles reserved on this resource. We eventually take the largest inverse throughput (i.e. smallest throughput) among all the resources as the overall throughput of this instruction.</p>
<p>A single <code>ProcResource</code> with number of unit larger than one is equivalent to multiple <em>identical</em> <code>ProcResource</code> instances. For example, let&rsquo;s say we have the following scheduling model:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span>def <span style="color:#89dceb">IEX</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">3</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteIMul, [IEX]<span style="color:#89dceb;font-weight:bold">&gt;</span>;</span></span></code></pre></div>
<p>In this model, we assign <code>IEX</code> (integer execution pipes) to <code>WriteIMul</code> &ndash; a SchedWrite token that represents integer multiplication instructions. This is equivalent to having three individual integer pipes &ndash; <code>IEX0</code>, <code>IEX1</code>, and <code>IEX2</code>, where <em>any</em> of them can do multiplications:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span>def <span style="color:#89dceb">IEX0</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">1</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>def <span style="color:#89dceb">IEX1</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">1</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>def <span style="color:#89dceb">IEX2</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">1</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;</span></span></code></pre></div>
<p>Having (effectively) three available pipes also means that we can dispatch three multiplications in parallel! Take the following RISC-V assembly snippet as an example, assuming we&rsquo;re dispatching them into this model with an issue width of 6. Since there is no Read-After-Write (RAW) dependencies among the instructions, we can dispatch them in parallel.</p>






<pre tabindex="0"><code>mul a1, a1, a2
mul t4, t4, t5
mul t0, t0, t1</code></pre>
<p>What we&rsquo;re interested in here, is how each of them <strong>consumes</strong> processor resources. We can visualize this process with the following resource consumption table:</p>
<table>
<thead>
<tr>
<th style="text-align:center">instruction</th>
<th style="text-align:center">IEX0</th>
<th style="text-align:center">IEX1</th>
<th style="text-align:center">IEX2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">mul a1, a1, a2</td>
<td style="text-align:center">Consumed</td>
<td style="text-align:center">Available</td>
<td style="text-align:center">Available</td>
</tr>
<tr>
<td style="text-align:center">mul t4, t4, t5</td>
<td style="text-align:center">Consumed</td>
<td style="text-align:center">Available</td>
<td style="text-align:center">Consumed</td>
</tr>
<tr>
<td style="text-align:center">mul t0, t0, t1</td>
<td style="text-align:center">Consumed</td>
<td style="text-align:center">Consumed</td>
<td style="text-align:center">Consumed</td>
</tr>
</tbody>
</table>
<p>The instructions are dispatched from top to bottom. For each of the instruction, we randomly<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> look for an empty pipe to dispatch it into.</p>
<p>Alternatively, we can rewrite this table into a more compact format:</p>
<table>
<thead>
<tr>
<th style="text-align:center">instruction</th>
<th style="text-align:center">Consumed IEX units</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">mul a1, a1, a2</td>
<td style="text-align:center">1 / 3</td>
</tr>
<tr>
<td style="text-align:center">mul t4, t4, t5</td>
<td style="text-align:center">2 / 3</td>
</tr>
<tr>
<td style="text-align:center">mul t0, t0, t1</td>
<td style="text-align:center">3 / 3</td>
</tr>
</tbody>
</table>
<p>In this table, we focus on the <em>number</em> of consumed units in <code>def IEX : ProcResource&lt;3&gt;</code>, where <code>2 / 3</code> means &ldquo;two out of three total units are consumed&rdquo;. This table will come into handy later when we&rsquo;re discussing more advanced scheduling model concepts.</p>
<p>But for now, let&rsquo;s step back for a second: if dispatching to <code>ProcResource&lt;3&gt;</code> is equivalent to doing the same thing against three individual <code>ProcResource&lt;1&gt;</code> where we can dispatch an instruction to <em>any</em> of them&hellip;</p>
<p>Haven&rsquo;t we seen something similar in the previous post already?</p>
<p>That&rsquo;s right! It&rsquo;s <code>ProcResGroup</code>. This is what we have after rewriting the same model with <code>ProcResGroup</code>:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span>def <span style="color:#89dceb">IEX0</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">1</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>def <span style="color:#89dceb">IEX1</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">1</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>def <span style="color:#89dceb">IEX2</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">1</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">4</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">5</span><span>def <span style="color:#89dceb">IEX</span> : ProcResGroup<span style="color:#89dceb;font-weight:bold">&lt;</span>[IEX0, IEX1, IEX2]<span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">6</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">7</span><span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteIMul, [IEX]<span style="color:#89dceb;font-weight:bold">&gt;</span>;</span></span></code></pre></div>
<p>Both models express the fact that multiplication instructions can run on any of the three integer pipes.</p>
<p>But then it prompts a question: if they&rsquo;re so similar, why do we have two different syntax in the first place?</p>
<p>The key, as it turns out, is the fact that we were dealing with three <strong>identical</strong> pipes in the previous example. In reality, we might not always have execution units with the same capabilities. For example, here is a more realistic design:</p>
<div style="text-align: center;">
  <picture>
    <source srcset="/images/llvm-sched-model-hierarchy-example.dark.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/llvm-sched-model-hierarchy-example.light.svg">
  </picture>
</div>
<p>In this design, only two out of three pipes are capable of doing multiplications; divisions and cryptographies, on the other hand, can only run on one of the pipes.</p>
<p>The rationale behind this design is that complex operations like division or cryptography usually take up a larger chip area and draw more power, while being less commonly used. So it&rsquo;s pretty common to have a heterogeneous layout where certain operations are only available in a subset of execution units.</p>
<p>With only a single <code>def IEX : ProcResource&lt;3&gt;</code>, it&rsquo;ll be more difficult to express the resources used by each kind of instructions because currently there is no way to say something like &ldquo;WriteIDiv uses the second unit of <code>IEX</code>&rdquo;:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 1</span><span>def <span style="color:#89dceb">IEX</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">3</span><span style="color:#89dceb;font-weight:bold">&gt;</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 2</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 3</span><span><span style="color:#6c7086;font-style:italic">// Simple arithmetics, like ADD
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 4</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteIALU,   [IEX]<span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 5</span><span><span style="color:#6c7086;font-style:italic">// Multiplication
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 6</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteIMul,   [<span style="color:#6c7086;font-style:italic">/*IEX[0] and IEX[2]??*/</span>]<span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 7</span><span><span style="color:#6c7086;font-style:italic">// Division
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 8</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteIDiv,   [<span style="color:#6c7086;font-style:italic">/*IEX[1]??*/</span>]<span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 9</span><span><span style="color:#6c7086;font-style:italic">// Cryptography
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">10</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteCrypto, [<span style="color:#6c7086;font-style:italic">/*IEX[2]??*/</span>]<span style="color:#89dceb;font-weight:bold">&gt;</span>;</span></span></code></pre></div>
<p>On the contrary, it&rsquo;s much more straight forward to express it with the <code>ProcResGroup</code> we had introduced in the <a href="/llvm-sched-model-1">previous post</a>:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 1</span><span>def <span style="color:#89dceb">IEX0</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">1</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 2</span><span>def <span style="color:#89dceb">IEX1</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">1</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 3</span><span>def <span style="color:#89dceb">IEX2</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">1</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 4</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 5</span><span>def <span style="color:#89dceb">IntegerArith</span> : ProcResGroup<span style="color:#89dceb;font-weight:bold">&lt;</span>[IEX0, IEX1, IEX2]<span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 6</span><span>def <span style="color:#89dceb">IntegerMul</span>   : ProcResGroup<span style="color:#89dceb;font-weight:bold">&lt;</span>[IEX0, IEX2]<span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 7</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 8</span><span><span style="color:#6c7086;font-style:italic">// Simple arithmetics, like ADD
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 9</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteIALU,   [IntegerArith]<span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">10</span><span><span style="color:#6c7086;font-style:italic">// Multiplication
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">11</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteIMul,   [IntegerMul]<span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">12</span><span><span style="color:#6c7086;font-style:italic">// Division
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">13</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteIDiv,   [IEX1]<span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">14</span><span><span style="color:#6c7086;font-style:italic">// Cryptography
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">15</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteCrypto, [IEX2]<span style="color:#89dceb;font-weight:bold">&gt;</span>;</span></span></code></pre></div>
<p>As a quick recap: by consuming <code>ProcResGroup&lt;[IEX0, IEX2]&gt;</code>, a multiplication instruction might run on either <code>IEX0</code> or <code>IEX2</code> during runtime.</p>
<p>It is worth pointing out that with this model, we have to deal with resource consumptions that go across <em>different</em> <code>ProcResource</code> and <code>ProcResGroup</code>. For instance, when we dispatch a cryptography instruction, the instruction not only consumes <code>IEX2</code> but also effectively decreases the number of available units in <code>IntegerArith</code> <strong>and</strong> <code>IntegerMul</code> &ndash; which is what multiplication consumes &ndash; because <code>IEX2</code> presents in both <code>ProcResGroup</code>.</p>
<p>In order to account for <strong>overlapping</strong> <code>ProcResource</code> and <code>ProcResGroup</code>, for each <code>ProcResource</code> or <code>ProcResGroup</code> used by an instruction, LLVM actually inserts an <em>implicit</em> processor resource usage for every <code>ProcResGroup</code> it overlaps. Using the snippet above as an example, this is what it looks like after such &ldquo;expansion&rdquo;:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#6c7086;font-style:italic">// Simple arithmetics, like ADD
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteIALU,   [IntegerArith]<span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span><span style="color:#6c7086;font-style:italic">// Multiplication
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">4</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteIMul,   [IntegerMul, IntegerArith]<span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">5</span><span><span style="color:#6c7086;font-style:italic">// Division
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">6</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteIDiv,   [IEX1, IntegerArith]<span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">7</span><span><span style="color:#6c7086;font-style:italic">// Cryptography
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">8</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteCrypto, [IEX2, IntegerArith, IntegerMul]<span style="color:#89dceb;font-weight:bold">&gt;</span>;</span></span></code></pre></div>
<p>A cryptography now consumes not only <code>IEX2</code>, but also one <code>IntegerArith</code> unit and one <code>IntegerMul</code> unit upon dispatch. So if we dispatch the following RISC-V instruction sequence<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>:</p>






<pre tabindex="0"><code>mul        s0, s0, a2
sha256sum0 a0, a1
mul        a3, a3, t0</code></pre>
<p>Here is what happens at cycle 0:</p>
<table>
<thead>
<tr>
<th style="text-align:center">instruction</th>
<th style="text-align:center">IntegerArith</th>
<th style="text-align:center">IntegerMul</th>
<th style="text-align:center">IEX2</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">mul s0, s0, a2</td>
<td style="text-align:center">1 / 3</td>
<td style="text-align:center">1 / 2</td>
<td style="text-align:center">0 / 1</td>
</tr>
<tr>
<td style="text-align:center">sha256sum0 a0, a1</td>
<td style="text-align:center">2 / 3</td>
<td style="text-align:center">2 / 2</td>
<td style="text-align:center">1 / 1</td>
</tr>
<tr>
<td style="text-align:center">mul a3, a3, t0</td>
<td style="text-align:center">3 / 3</td>
<td style="text-align:center">FAIL TO CONSUME</td>
<td style="text-align:center">1 / 1</td>
</tr>
</tbody>
</table>
<p>The first multiplication instruction consumes both <code>IntegerArith</code> <em>and</em> <code>IntegerMul</code>. Because <code>IntegerArith</code> has overlapping resources with <code>IntegerMul</code> &ndash; <code>IEX0</code> and <code>IEX2</code>, to be precise.</p>
<p>Similarly, when it comes to the <code>sha256sum0</code> instruction, it increases the number of consumed resources on not just <code>IEX2</code> but <code>IntegerArith</code> and <code>IntegerMul</code> as well. Lastly, for the last multiplication instruction, its attempt to acquire <code>IntegerMul</code> will fail because we no longer have spare capacity in that resource, which causes the instruction to <strong>stall</strong> during the dispatch stage, namely, a <em>dispatch hazard</em>.</p>
<p><code>ProcResGroup</code> gives you the ability to reference a <em>subset</em> of execution units, which is suitable for modeling units with heterogeneous capabilities. And as it turns out, there is actually a second way to reference subsets of execution units &ndash; <strong>super resource</strong>.</p>
<h3 id="super-resource">Super resource</h3>
<p>Super resource allows us to construct a hierarchy between two <code>ProcResource</code> instances (NOT <code>ProcResGroup</code>). In this relationship, the child <code>ProcResource</code> represents a subset of units from the parent <code>ProcResource</code>.</p>
<p>To give you a better idea, let&rsquo;s see a real-world example from the <strong>Load / Store Unit (LSU)</strong> in AMD Zen3.</p>
<figure style="text-align: center;">
  <img src="/images/zen3-uarch-lsu.png">
  <figcaption>Image source: <a href="https://chipsandcheese.com/2022/11/05/amds-zen-4-part-1-frontend-and-execution-engine/">Chips and Cheese</a>. Captured from the <a href="https://old.chipsandcheese.com/2022/11/05/amds-zen-4-part-1-frontend-and-execution-engine/zen3-drawio/"> original image </a>.</figcaption>
</figure>
<p>The diagram above shows the LSU part of <a href="https://old.chipsandcheese.com/2022/11/05/amds-zen-4-part-1-frontend-and-execution-engine/zen3-drawio/">Zen3&rsquo;s microarchitecture</a>. There are three arrows between load &amp; store queues and L1 Data Cache, along with an equal number of AGUs (Address Generation Unit) positioned above the queues.</p>
<p>You might notice that among all three arrows, which are load and store pipes, between the queues and L1 Data Cache, only two of them goes down (indicating <em>stores</em>) while there are three going up (indicating <em>loads</em>). This reveals that all three available pipes are capable of loading data, while only two of them (don&rsquo;t care which two of them though) can store data. Importantly, each pipe can either load or store data at any given time, but not both simultaneously.</p>
<p>This structure is described by <a href="https://github.com/llvm/llvm-project/blob/c503758ab6a4eacd3ef671a4a5ccf813995d4456/llvm/lib/Target/X86/X86ScheduleZnver3.td#L368">the following code</a> in Zen3&rsquo;s scheduling model:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 1</span><span>def <span style="color:#89dceb">Zn3LSU</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">3</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 2</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 3</span><span>let Super <span style="color:#89dceb;font-weight:bold">=</span> Zn3LSU in
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 4</span><span>def <span style="color:#89dceb">Zn3Load</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">3</span><span style="color:#89dceb;font-weight:bold">&gt;</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 5</span><span>  ...
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 6</span><span>}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 7</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 8</span><span>let Super <span style="color:#89dceb;font-weight:bold">=</span> Zn3LSU in
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 9</span><span>def <span style="color:#89dceb">Zn3Store</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">2</span><span style="color:#89dceb;font-weight:bold">&gt;</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">10</span><span>  ...
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">11</span><span>}</span></span></code></pre></div>
<p><code>Zn3Load</code> and <code>Zn3Store</code> are processor resources representing the load and store pipes, respectively. Both of them designate <code>Zn3LSU</code> &ndash; which represents the <em>entire</em> LSU &ndash; as their <strong>super resource</strong> via the <code>Super</code> field.</p>
<p>By designating <code>Zn3LSU</code> as their super resource, both <code>Zn3Load</code> and <code>Zn3Store</code> are essentially representing a subset of all three pipes from <code>Zn3LSU</code> &ndash; 2 pipes for <code>Zn3Store</code> and 3 for <code>Zn3Load</code>, coinciding with what we saw from Zen3&rsquo;s microarchitecture diagram earlier.
Put it differently, a unit from <code>Zn3LSU</code> can either be <em>allocated</em> as a load or a store pipe, while no more than two store pipes are allowed to exist at any given time.</p>
<p>LLVM implements super resource in a really similar way to how it implements <code>ProcResGroup</code> &ndash; by <em>expanding</em> <code>ProcResource</code> that has super resources. Let me explain this using the snippet below which shows some <code>Zn3Load</code> and <code>Zn3Store</code> usages.</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 1</span><span>def <span style="color:#89dceb">Zn3LSU</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">3</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 2</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 3</span><span>let Super <span style="color:#89dceb;font-weight:bold">=</span> Zn3LSU in
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 4</span><span>def <span style="color:#89dceb">Zn3Load</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">3</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 5</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 6</span><span>let Super <span style="color:#89dceb;font-weight:bold">=</span> Zn3LSU in
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 7</span><span>def <span style="color:#89dceb">Zn3Store</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">2</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 8</span><span>...
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 9</span><span><span style="color:#6c7086;font-style:italic">// Loads, stores, and moves, not folded with other operations.
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">10</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">defm</span> : Zn3WriteResInt<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteLoad,  [Zn3AGU012, Zn3Load], ...<span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">11</span><span><span style="color:#89dceb">defm</span> : Zn3WriteResInt<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteStore, [Zn3AGU012, Zn3Store], ...<span style="color:#89dceb;font-weight:bold">&gt;</span>;</span></span></code></pre></div>
<p>In this snippet, <code>WriteLoad</code> &ndash; the <code>SchedWrite</code> for some of the X86 load instructions &ndash; uses <code>Zn3AGU012</code> and <code>Zn3Load</code> while <code>WriteStore</code> &ndash; the <code>SchedRead</code> for some of the X86 store instructions &ndash; has a similar resource usage of <code>Zn3AGU012</code> and <code>Zn3Store</code>.</p>
<p>LLVM effectively expands the <code>Zn3Load</code> and <code>Zn3Store</code> usages in these two <code>SchedWrite</code> entries into:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#89dceb">defm</span> : Zn3WriteResInt<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteLoad,  [Zn3AGU012, Zn3Load,  Zn3LSU], ...<span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span><span style="color:#89dceb">defm</span> : Zn3WriteResInt<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteStore, [Zn3AGU012, Zn3Store, Zn3LSU], ...<span style="color:#89dceb;font-weight:bold">&gt;</span>;</span></span></code></pre></div>
<p>That&rsquo;s right! Similar to how <code>ProcResGroup</code> <em>implicitly</em> inserts resource usages of overlapping <code>ProcResGroup</code>, LLVM also <em>implicitly</em> inserts resource usages of super resource, <code>Zn3LSU</code>, into the list.</p>
<p>With the following sequence of X86 load and store instructions:</p>






<pre tabindex="0"><code>movq %r9,    (%rbx)   # store
movq 4(%r8), %rax     # load
movq %r10,   (%rcx)   # store</code></pre>
<p>They&rsquo;ll have the following resource consumptions upon dispatch (<code>Zn3AGU012</code> is omitted from this table for simplicity):</p>
<table>
<thead>
<tr>
<th style="text-align:center">instruction</th>
<th style="text-align:center">Zn3Load</th>
<th style="text-align:center">Zn3Store</th>
<th style="text-align:center">Zn3LSU</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">movq %r9, (%rbx)</td>
<td style="text-align:center">0 / 3</td>
<td style="text-align:center">1 / 2</td>
<td style="text-align:center">1 / 3</td>
</tr>
<tr>
<td style="text-align:center">movq 4(%r8), %rax</td>
<td style="text-align:center">1 / 3</td>
<td style="text-align:center">1 / 2</td>
<td style="text-align:center">2 / 3</td>
</tr>
<tr>
<td style="text-align:center">movq %r10, (%rcx)</td>
<td style="text-align:center">1 / 3</td>
<td style="text-align:center">2 / 2</td>
<td style="text-align:center">3 / 3</td>
</tr>
</tbody>
</table>
<p>Whenever a store (e.g. <code>movq %r9, (%rbx)</code>) is being dispatched, it increases the counters of both <code>Zn3Store</code> and <code>Zn3LSU</code>. Similarly, a load instruction increases both <code>Zn3Load</code> and <code>Zn3LSU</code> counters.</p>
<p>Let&rsquo;s use the following consecutive store instructions to show how we throttle the number of store pipes to 2:</p>






<pre tabindex="0"><code>movq %r9,  (%rbx)   # store
movq %rax, (%r8)    # store
movq %r10, (%rcx)   # store</code></pre>
<p>This snippet produces the following resource consumption table:</p>
<table>
<thead>
<tr>
<th style="text-align:center">instruction</th>
<th style="text-align:center">Zn3Load</th>
<th style="text-align:center">Zn3Store</th>
<th style="text-align:center">Zn3LSU</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">movq %r9, (%rbx)</td>
<td style="text-align:center">0 / 3</td>
<td style="text-align:center">1 / 2</td>
<td style="text-align:center">1 / 3</td>
</tr>
<tr>
<td style="text-align:center">movq %rax, (%r8)</td>
<td style="text-align:center">0 / 3</td>
<td style="text-align:center">2 / 2</td>
<td style="text-align:center">2 / 3</td>
</tr>
<tr>
<td style="text-align:center">movq %r10, (%rcx)</td>
<td style="text-align:center">0 / 3</td>
<td style="text-align:center">FAIL TO CONSUME</td>
<td style="text-align:center">3 / 3</td>
</tr>
</tbody>
</table>
<p>The last instruction fails to consume <code>Zn3Store</code>, because it only has a total of 2 units.
In other words, the last instruction in this case is throttled by <code>Zn3Store</code>, despite the fact that there are enough number of LSU pipes.</p>
<p>And that, is how Zen3 uses super resource to set a cap on the number of store pipes in its scheduling model.</p>
<h3 id="procresgroup-vs-super-resource">ProcResGroup v.s. Super resource</h3>
<p>So far, we have learned how to use <code>ProcResGroup</code> and super resource. Naturally we want to ask: what are their actual differences and, more importantly, <strong>when</strong> should I use them?</p>
<p>Conceptually, both super resource and <code>ProcResGroup</code> provide a way to reference a subset of a larger collection of hardware units. Super resource creates a &ldquo;slice&rdquo; of an existing <code>ProcResource</code>; <code>ProcResGroup</code> approaches this from an opposite direction: it combines multiple smaller <code>ProcResource</code> into a larger set, so that we can either reference to the larger set or the original individual resource.</p>
<p>The main difference between them comes up when execution pipes have certain kinds of <em>partially</em> overlapping capabilities, like this:</p>
<div style="text-align: center;">
  <picture>
    <source srcset="/images/llvm-sched-model-partial-res-overlap.dark.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/llvm-sched-model-partial-res-overlap.light.svg">
  </picture>
</div>
<p>First, let&rsquo;s (try to) describe this model with super resource in the following way:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 1</span><span><span style="color:#6c7086;font-style:italic">// Note: this is the WRONG approach
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 2</span><span><span style="color:#6c7086;font-style:italic"></span>def <span style="color:#89dceb">IEX</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">3</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 3</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 4</span><span>let Super <span style="color:#89dceb;font-weight:bold">=</span> IEX in {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 5</span><span>  def <span style="color:#89dceb">IntegerArith</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">2</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 6</span><span>  def <span style="color:#89dceb">IntegerMul</span>   : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">2</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 7</span><span>  def <span style="color:#89dceb">IntegerDiv</span>   : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">1</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 8</span><span>}
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 9</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">10</span><span><span style="color:#6c7086;font-style:italic">// Simple arithmetics, like ADD
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">11</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteIALU,   [IntegerArith]<span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">12</span><span><span style="color:#6c7086;font-style:italic">// Multiplication
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">13</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteIMul,   [IntegerMul]<span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">14</span><span><span style="color:#6c7086;font-style:italic">// Division
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">15</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteIDiv,   [IntegerDiv]<span style="color:#89dceb;font-weight:bold">&gt;</span>;</span></span></code></pre></div>
<p>In hindsight, this model looks correct: two out of three pipes can be allocated to MUL or ALU, while only a single pipe can be used for divisions. But things start to get off the track when we run the following RISC-V snippet through this model.</p>






<pre tabindex="0"><code>mul a1, a1, a2
mul t4, t4, t5
div s0, s0, t0</code></pre>
<p>First, let&rsquo;s expand those <code>WriteRes</code> entries:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#6c7086;font-style:italic">// Simple arithmetics, like ADD
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteIALU,   [IntegerArith, IEX]<span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span><span style="color:#6c7086;font-style:italic">// Multiplication
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">4</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteIMul,   [IntegerMul, IEX]<span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">5</span><span><span style="color:#6c7086;font-style:italic">// Division
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">6</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteIDiv,   [IntegerDiv, IEX]<span style="color:#89dceb;font-weight:bold">&gt;</span>;</span></span></code></pre></div>
<p><code>IntegerArith</code>, <code>IntegerMul</code>, and <code>IntegerDiv</code> all have <code>IEX</code> as its super resource, which is implicitly inserted into the list of resource usages in all three entries.</p>
<p>With this expansion, we can pan out the (plausibly correct) resource consumption table:</p>
<table>
<thead>
<tr>
<th style="text-align:center">instruction</th>
<th style="text-align:center">IntegerArith</th>
<th style="text-align:center">IntegerMul</th>
<th style="text-align:center">IntegerDiv</th>
<th style="text-align:center">IEX</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">mul a1, a1, a2</td>
<td style="text-align:center">0 / 2</td>
<td style="text-align:center">1 / 2</td>
<td style="text-align:center">0 / 1</td>
<td style="text-align:center">1 / 3</td>
</tr>
<tr>
<td style="text-align:center">mul t4, t4, t5</td>
<td style="text-align:center">0 / 2</td>
<td style="text-align:center">2 / 2</td>
<td style="text-align:center">0 / 1</td>
<td style="text-align:center">2 / 3</td>
</tr>
<tr>
<td style="text-align:center">div s0, s0, t0</td>
<td style="text-align:center">0 / 2</td>
<td style="text-align:center">2 / 2</td>
<td style="text-align:center">1 / 1</td>
<td style="text-align:center">3 / 3</td>
</tr>
</tbody>
</table>
<p>Again, each instruction gets the resources they demanded and everything looks correct &ndash; until you realize that if both <code>IEX1</code> <strong>and</strong> <code>IEX2</code>, the multiplication-capable pipes, have already been consumed, how can the last instruction be dispatched to <code>IEX1</code>, the <em>only</em> pipe that is capable of doing division?</p>
<p>Now, you might try to fix this by assigning a different super resource to <code>IntegerDiv</code>, let&rsquo;s say <code>IntegerMul</code>:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#6c7086;font-style:italic">// ????
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span><span style="color:#6c7086;font-style:italic"></span>let Super <span style="color:#89dceb;font-weight:bold">=</span> IntegerMul in
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>def <span style="color:#89dceb">IntegerDiv</span>   : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">1</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;</span></span></code></pre></div>
<p>But then we will run into the same problem if we have the following RISC-V snippet, in which <code>add</code> instructions use <code>IntegerALU</code>:</p>






<pre tabindex="0"><code>add a1, a1, a2
add t4, t4, t5
div s0, s0, t0</code></pre>
<p>Because the first two <code>add</code> instructions will already consume both <code>IEX0</code> and <code>IEX1</code> before division tries to grab <code>IEX1</code> that is no longer available.</p>
<p>The root cause for the problem we have here is that we cannot declare both <code>IntegerMul</code> <em>and</em> <code>IntegerALU</code> as the super resource of <code>IntegerDiv</code>. Super resource is only effective if you can organize the <code>ProcResource</code> hierarchy into a <strong>tree</strong>.</p>
<p>Take the processor model we used at the beginning of this post as the example, we can easily organize their processor resources into a tree as shown in the figure below.</p>
<div style="text-align: center;">
  <picture>
    <source srcset="/images/llvm-sched-model-hierarchy-tree.dark.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/llvm-sched-model-hierarchy-tree.light.svg">
    <figcaption>Left: processor model. Right: organized their hierarchy into a tree</figcaption>
  </picture>
</div>
<p>On the other hand, the processor model we saw in this section can only be expressed with a <strong>DAG</strong>:</p>
<div style="text-align: center;">
  <picture>
    <source srcset="/images/llvm-sched-model-partial-res-overlap-dag.dark.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/llvm-sched-model-partial-res-overlap-dag.light.svg">
    <figcaption>Left: processor model. Right: organized their hierarchy into a DAG</figcaption>
  </picture>
</div>
<p>Of course, we can easily describe this model with DAG structure using <code>ProcResGroup</code>:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 1</span><span>def <span style="color:#89dceb">IEX0</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">1</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 2</span><span>def <span style="color:#89dceb">IEX1</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">1</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 3</span><span>def <span style="color:#89dceb">IEX2</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">1</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 4</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 5</span><span>def <span style="color:#89dceb">IntegerArith</span> : ProcResGroup<span style="color:#89dceb;font-weight:bold">&lt;</span>[IEX0, IEX1]<span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 6</span><span>def <span style="color:#89dceb">IntegerMul</span>   : ProcResGroup<span style="color:#89dceb;font-weight:bold">&lt;</span>[IEX1, IEX2]<span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 7</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 8</span><span><span style="color:#6c7086;font-style:italic">// Simple arithmetics, like ADD
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 9</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteIALU,   [IntegerArith]<span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">10</span><span><span style="color:#6c7086;font-style:italic">// Multiplication
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">11</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteIMul,   [IntegerMul]<span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">12</span><span><span style="color:#6c7086;font-style:italic">// Division
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">13</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteIDiv,   [IEX1]<span style="color:#89dceb;font-weight:bold">&gt;</span>;</span></span></code></pre></div>
<p>After expansion, we effectively have the following <code>WriteRes</code> entries:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#6c7086;font-style:italic">// Simple arithmetics, like ADD
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteIALU,   [IntegerArith]<span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span><span style="color:#6c7086;font-style:italic">// Multiplication
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">4</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteIMul,   [IntegerMul]<span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">5</span><span><span style="color:#6c7086;font-style:italic">// Division
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">6</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteIDiv,   [IEX1, IntegerArith, IntegerMul]<span style="color:#89dceb;font-weight:bold">&gt;</span>;</span></span></code></pre></div>
<p>Now <code>WriteIDiv</code> consumes not just <code>IEX1</code> but also <code>IntegerArith</code> and <code>IntegerMul</code> &ndash; the <em>predecessors</em> of the division resource in the DAG we just saw.</p>
<p>If we run this model over one of the earlier snippets:</p>
<table>
<thead>
<tr>
<th style="text-align:center">instruction</th>
<th style="text-align:center">IntegerArith</th>
<th style="text-align:center">IntegerMul</th>
<th style="text-align:center">IEX1</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">mul a1, a1, a2</td>
<td style="text-align:center">0 / 2</td>
<td style="text-align:center">1 / 2</td>
<td style="text-align:center">0 / 1</td>
</tr>
<tr>
<td style="text-align:center">mul t4, t4, t5</td>
<td style="text-align:center">0 / 2</td>
<td style="text-align:center">2 / 2</td>
<td style="text-align:center">0 / 1</td>
</tr>
<tr>
<td style="text-align:center">div s0, s0, t0</td>
<td style="text-align:center">1 / 2</td>
<td style="text-align:center">FAIL TO CONSUME</td>
<td style="text-align:center">1 / 1</td>
</tr>
</tbody>
</table>
<p>The division instruction is unable to be dispatched, because it failed to consume the <code>IntegerMul</code> resource &ndash; and this behavior is something we expect.</p>
<p>I hope you&rsquo;re now convinced that <code>ProcResGroup</code> is more flexible and more generic than super resource, because it can express models with either tree or non-tree structures. This comes unsurprised as <code>ProcResGroup</code> was actually <a href="https://github.com/llvm/llvm-project/commit/4e67cba8a65bba60e60f48083269917b39b4e3de">invented</a> <em>later</em> than super resource.</p>
<p>That said, super resource might come handy when we only care about the number of processor units and referencing the exact pipes is less important. For example, in an extreme situation where there are a total of <em>12</em> execution pipes in a model, instead of spelling out all processor resources like this<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span>def <span style="color:#89dceb">IEX0</span>  : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">1</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>def <span style="color:#89dceb">IEX1</span>  : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">1</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>...
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">4</span><span>def <span style="color:#89dceb">IEX11</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">1</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">5</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">6</span><span><span style="color:#6c7086;font-style:italic">// I make up these groupings, the point is that it&#39;s
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">7</span><span><span style="color:#6c7086;font-style:italic">// quite cumbersome to reference every IEX pipe they use.
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">8</span><span><span style="color:#6c7086;font-style:italic"></span>def <span style="color:#89dceb">IntegerArith</span> : ProcResGroup<span style="color:#89dceb;font-weight:bold">&lt;</span>[IEX0, IEX1, ...]<span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">9</span><span>def <span style="color:#89dceb">IntegerMul</span>   : ProcResGroup<span style="color:#89dceb;font-weight:bold">&lt;</span>[IEX6, IEX8, ...]<span style="color:#89dceb;font-weight:bold">&gt;</span>;</span></span></code></pre></div>
<p>It&rsquo;s certainly easier and more concise to write:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span>def <span style="color:#89dceb">IEX</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">12</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>let Super <span style="color:#89dceb;font-weight:bold">=</span> IEX in {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">4</span><span>  def <span style="color:#89dceb">IntegerArith</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">12</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">5</span><span>  def <span style="color:#89dceb">IntegerMul</span>   : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">6</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">6</span><span>}</span></span></code></pre></div>
<h3 id="summary">Summary</h3>
<p>To conclude, in this post we discussed several options to express processor resources with hierarchy structures. Notably, <code>ProcResGroup</code> and super resource. The takeaway is that <code>ProcResGroup</code> is generally more flexible and versitile than the other options, but can be quite verbose in some cases, in which super resource or even just plain <code>ProcResource</code> with multiple units is more desirable.</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>The actual dispatching algorithm in real processors is much more complicated, but let&rsquo;s just assume it looks for available pipes without any specific order.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>Again, using a processor with issue width of 6&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>Even we can simplify it with <code>foreach</code> and some other TableGen magic, I&rsquo;m sure it&rsquo;s still more verbose than using super resource.&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded></item><item><title>When LLVM scalable vector meets RISC-V</title><link>https://myhsu.xyz/llvm-riscv-bits-per-block/</link><pubDate>Sat, 05 Oct 2024 00:00:00 +0000</pubDate><author>min@myhsu.dev (Min-Yih Hsu)</author><guid>https://myhsu.xyz/llvm-riscv-bits-per-block/</guid><description>There is a nice page about how LLVM handles RISC-V Vector Extension (RVV). It primarily covers how the RISC-V backend lowers vector types and vector operations. Right at the beginning of the page lies this table:
It shows the LLVM IR types we use to represent RVV&amp;rsquo;s dynamically sized vectors: each row is an element type, while each column is a LMUL &amp;ndash; the register grouping factor, or &amp;ldquo;how many vector registers should we slap together and treat it as a single logical vector register&amp;rdquo;.</description><content:encoded><![CDATA[<p>There is a <a href="https://llvm.org/docs/RISCV/RISCVVectorExtension.html">nice page</a> about how LLVM handles RISC-V Vector Extension (RVV). It primarily covers how the RISC-V backend lowers vector types and vector operations. Right <a href="https://llvm.org/docs/RISCV/RISCVVectorExtension.html#mapping-to-llvm-ir-types">at the beginning of the page</a> lies this table:</p>
<figure style="text-align: center;">
  <img src="/images/llvm-rvv-ir-types.png">
</figure>
<p>It shows the LLVM IR types we use to represent RVV&rsquo;s <em>dynamically</em> sized vectors: each row is an element type, while each column is a <strong>LMUL</strong> &ndash; the register grouping factor, or &ldquo;how many vector registers should we slap together and treat it as a single <em>logical</em> vector register&rdquo;.</p>
<p>For instance, when LMUL = 4, each vector instruction effectively operates on a (gigantic) logical vector register that is four-time the size of a normal vector register. Under this LMUL setting, a RVV vector of 64-bit integer (i.e. <code>i64</code>) is represented by IR type <code>&lt;vscale x 4 x i64&gt;</code> according to the table.</p>
<p>Both LMUL and the element type can be changed at any point during the runtime, hence the dynamically sized vectors.</p>
<p>The <code>&lt;vscale x 4 x i64&gt;</code> is a <strong>scalable vector type</strong> in LLVM. It looks similar to a normal (fixed) vector type like <code>&lt;4 x i64&gt;</code> &ndash; a vector of four 64-bit integers &ndash; but the &ldquo;vscale&rdquo; keyword gives it the ability to scale the &ldquo;base&rdquo; vector type &ndash; namely, the <code>4 x i64</code> part, where 4 here is the <u>minimum number of elements</u> &ndash; by a certain factor, vscale, that is only known during runtime. So if vscale equals to 2 during runtime, we have an equivalent vector of <code>&lt;8 x i64&gt;</code>; <code>&lt;16 x i64&gt;</code> when vscale is 4. Simple, right?</p>
<p>Well&hellip;it looks simple until you squint a little harder at the table we just showed and start wonder: <em>how</em> exactly does RVV LMUL map to different scalable vector IR types? how do we calculate the minimum number of elements?</p>
<p>Using LMUL = 4 again as an example, but this time we want to use <code>i32</code> as the element type. Intuitively, we would have thought the corresponding scalable vector type to be <code>&lt;vscale x 4 x i32&gt;</code> because the minimum number of elements is equal to LMUL, right? &ndash; except it is not, it&rsquo;s actually <code>&lt;vscale x 8 x i32&gt;</code>.</p>
<p>To find the answer, we navigate to a line sitting just above the table in the same page:</p>
<blockquote>
<p>&hellip;vscale is defined as VLEN/64 (see RISCV::RVVBitsPerBlock).</p>
</blockquote>
<p>It suggests that we can calculate the minimum number of scalable vector elements for a RVV type using <code>RISCV::RVVBitsPerBlock</code>, a magic constant that is <a href="https://github.com/llvm/llvm-project/blob/bf895c714e1f8a51c1e565a75acf60bf7197be51/llvm/include/llvm/TargetParser/RISCVTargetParser.h#L36">set to 64</a>.
The code comment for <code>RISCV::RVVBitsPerBlock</code> doesn&rsquo;t explain a lot, nor is clear what &ldquo;block&rdquo; here means.</p>
<p>In this short post, I&rsquo;m going to explain how the table is created and the actual purpose of this mystery <code>RISCV::RVVBitsPerBlock</code> constant.</p>
<h3 id="arm-sve----the-origin-of-scalable-vector-types">ARM SVE &ndash; the origin of scalable vector types</h3>
<p>I know it&rsquo;s weird to start a RISC-V blog post with ARM, but I think it&rsquo;s imperative to understand the origin of scalable vector types in LLVM first.</p>
<p>ARM introduced SVE (Scalable Vector Extension) about 8 years ago. SVE allows vector registers to scale their size by a certain runtime factor, <code>LEN</code>. The figure below<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> shows the structure of vector registers in SVE.</p>
<div style="text-align: center;">
  <picture>
    <source srcset="/images/arm-sve.dark.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/arm-sve.light.svg">
    <figcaption>Scalable vector registers in ARM SVE</figcaption>
  </picture>
</div>
<p>When <code>LEN</code> is set to 3, each vector registers <code>Z0</code> ~ <code>Z31</code> has a size of 512 bits (128 * 3 + 128).</p>
<p>Sounds familiar, right? That&rsquo;s because the scalable vector type in LLVM we just talked about was introduced by ARM folks for SVE, and it&rsquo;s using the exact same principle.</p>
<p>In the most basic setting, the scalable vector type for a SVE vector has minimum number of elements equal to 128 divided by element size, like <code>&lt;vscale x 4 x i32&gt;</code> or <code>&lt;vscale x 2 x i64&gt;</code>. And during runtime, vscale is equal to <code>LEN + 1</code>.</p>
<p>If we think of a single SVE vector register being multiple 128-bit vector registers slapped together &ndash; which I believe it is indeed what happens in hardware &ndash; the runtime factor (i.e. <code>LEN</code>) dictates the <em>number</em> of those fixed-size, 128-bit registers.</p>
<p>Now we learned that LLVM&rsquo;s scalable vector type is basically a 1:1 mapping to ARM SVE vectors, let&rsquo;s see how well (or bad) it maps to RISC-V vectors.</p>
<h3 id="scalable-vector-types-meet-rvv">Scalable vector types meet RVV</h3>
<p>In RVV, each vector register, <code>v0</code> ~ <code>v31</code>, has a size of <code>VLEN</code> bits. <code>VLEN</code> is a hardware-defined constant. Though each RISC-V processor has its own fixed-value <code>VLEN</code>, the software doesn&rsquo;t know it during compile time &ndash; assuming you&rsquo;re building a portable binary.</p>
<p>As introduced earlier in the post, RVV instructions operate on logical vector register, which is a group of LMUL actual vector registers, as depicted by the following figure.</p>
<div style="text-align: center;">
  <picture>
    <source srcset="/images/rvv-registers.dark.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/rvv-registers.light.svg">
    <figcaption>RISC-V vector registers</figcaption>
  </picture>
</div>
<p>To update the current LMUL and element type &ndash; which is also known as <strong>SEW</strong> (Selected Element Width) &ndash; during runtime, we can use instructions like <code>vsetvl</code> and <code>vsetvli</code>.</p>
<p>For instance, <code>vsetvl rd, rs1, rs2</code> updates the current LMUL and SEW settings according to the (runtime) value stored in scalar register <code>rs2</code>. This LMUL + SEW combination &ndash; part of a RVV setting called <strong>vtype</strong> &ndash; will continue to hold until another <code>vsetvl</code>-family instruction change the vtype.</p>
<p>Here is the catch: compilers do NOT generate <code>vsetvl</code> in like 99% of the cases.</p>
<p>Instead, we use one of its siblings, <code>vsetvli</code>, which encodes the desired vtype with <em>immediate value</em> operands. For instance, <code>vsetvli x2, x0, e32, m4</code> sets the new LMUL into 4 because of <code>m4</code>, an immediate value, and the new SEW to be 32-bit wide because of <code>e32</code>, also an immediate value.</p>
<p>With <code>vsetvli</code>, we can actually know the exact LMUL of a certain region of code <em>ahead of time</em>. For example, the following snippet uses different vtype settings in three different regions, but we&rsquo;re able to statically determine the exact LMUL (and SEW) values in each region.</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-asm" data-lang="asm"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 1</span><span><span style="color:#89b4fa">vsetvli</span> <span style="color:#f9e2af">t0</span>, <span style="color:#f9e2af">zero</span>, <span style="color:#f9e2af">e32</span>, <span style="color:#f9e2af">m2</span>, <span style="color:#f9e2af">ta</span>, <span style="color:#f9e2af">ma</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 2</span><span><span style="color:#6c7086;font-style:italic"># === operate on LMUL=2 &amp; SEW of 32 bits ====
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 3</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89b4fa">vadd.vv</span> <span style="color:#f9e2af">v2</span>, <span style="color:#f9e2af">v2</span>, <span style="color:#f9e2af">v4</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 4</span><span><span style="color:#89b4fa">vadd.vv</span> <span style="color:#f9e2af">v2</span>, <span style="color:#f9e2af">v2</span>, <span style="color:#f9e2af">v6</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 5</span><span><span style="color:#6c7086;font-style:italic"># ===========================================
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 6</span><span><span style="color:#6c7086;font-style:italic"></span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 7</span><span><span style="color:#89b4fa">vsetvli</span> <span style="color:#f9e2af">t0</span>, <span style="color:#f9e2af">zero</span>, <span style="color:#f9e2af">e32</span>, <span style="color:#f9e2af">m4</span>, <span style="color:#f9e2af">ta</span>, <span style="color:#f9e2af">ma</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 8</span><span><span style="color:#6c7086;font-style:italic"># === operate on LMUL=4 &amp; SEW of 32 bits ====
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 9</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89b4fa">vadd.vv</span> <span style="color:#f9e2af">v0</span>, <span style="color:#f9e2af">v0</span>, <span style="color:#f9e2af">v4</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">10</span><span><span style="color:#89b4fa">vadd.vv</span> <span style="color:#f9e2af">v0</span>, <span style="color:#f9e2af">v0</span>, <span style="color:#f9e2af">v8</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">11</span><span><span style="color:#6c7086;font-style:italic"># ===========================================
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">12</span><span><span style="color:#6c7086;font-style:italic"></span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">13</span><span><span style="color:#89b4fa">vsetvli</span> <span style="color:#f9e2af">t0</span>, <span style="color:#f9e2af">zero</span>, <span style="color:#f9e2af">e64</span>, <span style="color:#f9e2af">m4</span>, <span style="color:#f9e2af">ta</span>, <span style="color:#f9e2af">ma</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">14</span><span><span style="color:#6c7086;font-style:italic"># === operate on LMUL=4 &amp; SEW of 64 bits ====
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">15</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89b4fa">vadd.vv</span> <span style="color:#f9e2af">v0</span>, <span style="color:#f9e2af">v0</span>, <span style="color:#f9e2af">v4</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">16</span><span><span style="color:#89b4fa">vadd.vv</span> <span style="color:#f9e2af">v0</span>, <span style="color:#f9e2af">v0</span>, <span style="color:#f9e2af">v8</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">17</span><span><span style="color:#6c7086;font-style:italic"># ===========================================
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">18</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89b4fa">ret</span></span></span></code></pre></div>
<p>The bottom line is that in most cases, LMUL is considered to be &ldquo;semi-dynamic&rdquo; &ndash; it might change during runtime, but in a more <em>deterministic</em> way.</p>
<p>And that is one of the reasons why RISC-V backend assigns each LMUL (and SEW) a unique scalable vector type &ndash; because it is possible to determine it during compile time. In comparison, ARM SVE folds all the dynamic bits into a single parameter, vscale.</p>
<p>But now a new problem emerges: <code>VLEN</code> is unknown during compile time, because different RISC-V processors might have different <code>VLEN</code> values. Without knowing the exact value of <code>VLEN</code> we&rsquo;re unable to know the number of elements in a single vector register, which is different from SVE&rsquo;s case because the latter effectively has a &ldquo;base&rdquo; vector register of 128 bits.</p>
<p>Let&rsquo;s try to solve this problem with one of our (incorrect) intuitions mentioned earlier: use LMUL &ndash; the &ldquo;known&rdquo; value &ndash; as the minimum number of elements in a scalable vector type, and fold every unknowns &ndash; including <code>VLEN</code> &ndash; into vscale. So LMUL=4 + SEW=32 becomes <code>&lt;vscale x 4 x i32&gt;</code> or <code>&lt;vscale x 4 x f32&gt;</code>.</p>
<p>To illustrate this solution, let&rsquo;s rearrange our RVV LMUL figure earlier so that the unknown part, <code>VLEN</code>, is put along the horizontal axis, while individual vector registers are arranged vertically with the respective LMUL quantity.</p>
<div style="text-align: center;">
  <picture>
    <source srcset="/images/rvv-sve-registers-naive.dark.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/rvv-sve-registers-naive.light.svg">
    <figcaption>A naive way to map RVV vectors to scalable vector types</figcaption>
  </picture>
</div>
<p>In this solution, RVV&rsquo;s vscale value is equal to the number of (vertical) dotted boxes, <code>VLEN / SEW</code>. This means that we might have different vscale at different code regions since SEW might change (recall the snippet shown above) &ndash; and that, causes lots of inconveniences.</p>
<p>The value of vscale is essential to estimating the number of vector elements, which directly relates to many things like <em>vectorization factors</em> (i.e. how many items can we process in a single iteration of a vectorized loop). Having a more predictable range of vscale is always preferrable to the optimizers.</p>
<p>To have a vscale value that doesn&rsquo;t depend on <code>SEW</code>, there is a simple trick: create a fake, <em>fixed-size</em> &ldquo;base vector&rdquo; similar to what SVE has.</p>
<div style="text-align: center;">
  <picture>
    <source srcset="/images/rvv-register-final.dark.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/rvv-register-final.light.svg">
  </picture>
</div>
<p>The figure above used a fake base vector of 64 bits, which contains 2 elements in it when SEW=32. Combining with LMUL=4, we get eight 32-bit elements in a single dotted box. Again, vscale value is equal to the number of dotted boxes, but this time, we can easily evaluate it with <code>VLEN / 64</code> &ndash; vscale no longer depends on <code>SEW</code>.</p>
<p>The size of the fake base vector, 64 bits in this example, is <code>RISCV::RISCVBitsPerBlock</code>. To put it differently, in RISC-V backend, the vscale value is always equal to <code>VLEN / RISCV::RISCVBitsPerBlock</code>.</p>
<p>It sound a little bit like magic where the <code>SEW</code> factor just suddenly disappears from the equation. But what it really does was simply using the <em>least common multiple (LCM)</em> of all the supported SEW (8, 16, 32, and 64 bits) to &ldquo;tile&rdquo; <code>VLEN</code>. The downside of this design is that we can&rsquo;t support 32-bit <code>VLEN</code> out of the box, which is a known limitation in RISC-V LLVM backend. It sounds a little unusual to have such a small vector size of 32 bits, but apparently <code>Zve32*</code> extensions were created to put vectors into embedded devices, in which case a smaller vector sizes makes more sense.</p>
<p>Granted, it&rsquo;s not really common to use <code>RISCV::RISCVBitsPerBlock</code> directly, but I thought it&rsquo;s fun to know where it came from and why it&rsquo;s created in the first place. And that&rsquo;s all for this short post! Hope you enjoy.</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>I redrew <a href="https://developer.arm.com/documentation/102476/0100/SVE-architecture-fundamentals/Scalable-vector-registers-z0-z31?lang=en">this figure</a> from ARM&rsquo;s official document. Because the original figure missed an important component &ndash; it&rsquo;s &ldquo;LEN x 128&rdquo;, not just &ldquo;LEN 128&rdquo;.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded></item><item><title>Scheduling Model in LLVM - Part I</title><link>https://myhsu.xyz/llvm-sched-model-1/</link><pubDate>Mon, 05 Aug 2024 00:00:00 +0000</pubDate><author>min@myhsu.dev (Min-Yih Hsu)</author><guid>https://myhsu.xyz/llvm-sched-model-1/</guid><description>Instruction scheduling is essential to modern compilers. It tries to hide latencies and increases the throughput of a straight line code by reordering the enclosing instructions. In order to do that, compilers have to know a whole bunch of information, ranging from individual instruction&amp;rsquo;s latency to microarchitecture details. The system that describes these is called a scheduling model. In LLVM, a scheduling model is used by not just the instruction scheduler, but also target-specific optimizations like MachineCombiner and components like MCA (Machine Code Analyzer)1.</description><content:encoded><![CDATA[<p>Instruction scheduling is essential to modern compilers. It tries to hide latencies and increases the throughput of a straight line code by reordering the enclosing instructions.
In order to do that, compilers have to know a whole bunch of information, ranging from individual instruction&rsquo;s latency to microarchitecture details. The system that describes these is called a scheduling model. In LLVM, a scheduling model is used by not just the instruction scheduler, but also target-specific optimizations like MachineCombiner and components like MCA (Machine Code Analyzer)<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>. Which makes it an important factor in performance tuning for low-level code.</p>
<p>This series is about LLVM&rsquo;s scheduling model, how it interacts / affects other parts of LLVM and how can we fine tune this model for better performance. I&rsquo;ll cover how scheduling models are used in other part of LLVM in later posts, but in this one, I&rsquo;m focusing on the scheduling model itself first, and talk about how to specify scheduling information for individual instructions. Let&rsquo;s start with a really basic example.</p>
<h3 id="the-basics">The Basics</h3>
<p>Scheduling models are part of the target definition. They are associated with one or more target processors. Multiple processors can also share the same scheduling model. Take RISC-V as an example, we can find <a href="https://github.com/llvm/llvm-project/blob/fdb9f96fa2a926425bdf8315048db7623d63547d/llvm/lib/Target/RISCV/RISCVSchedSiFive7.td">one</a> of its scheduling models, <code>SiFive7Model</code>, covers a wide array of processors from <code>sifive-e76</code>, a 32-bit microcontroller, to <code>sifive-x280</code>, which is a high-performance processor designed for AI/ML workloads.</p>
<p>To describe per-instruction scheduling information like latency, naively, we can express such information with descriptions like <em>&ldquo;opcode ADD has latency of X&rdquo;</em>. It&rsquo;s all fun and games until you realize that there are tens of thousands of opcodes in some of the targets<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> so it doesn&rsquo;t scale well. More importantly, many instructions share the same scheduling characteristics.
For example, simple arithmetic operations like add, sub, and shifts usually have the same latency in most modern architectures.</p>
<p>Instead of spelling out per-opcode information, LLVM chooses a different path that characterizes an instruction&rsquo;s scheduling properties with <strong>operand reads and writes</strong>:
First, each operand in an instruction is assigned with a &ldquo;token&rdquo;.</p>
<p>Take the <a href="https://github.com/llvm/llvm-project/blob/e70f376b25ea96f3b0db75ff77ae1a58d53f2119/llvm/lib/Target/RISCV/RISCVInstrInfoM.td#L39">DIV instruction</a> in RISC-V shown below as an example, <code>WriteIDIV</code> is the token assigned to the first operand, which is also the destination register, hence a <em>write</em> operand (also called <strong>definition</strong>). The two <code>ReadIDIV</code> follow are tokens for the two source registers, both are <em>read</em> operands (or <strong>use</strong>).</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#6c7086;font-style:italic">// From llvm/lib/Target/RISCV/RISCVInstrInfoM.td.
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span><span style="color:#6c7086;font-style:italic"></span>def <span style="color:#89dceb">DIV</span>     : ALU_rr<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">0b0000001</span>, <span style="color:#fab387">0b100</span>, <span style="color:#a6e3a1">&#34;div&#34;</span><span style="color:#89dceb;font-weight:bold">&gt;</span>,
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>              Sched<span style="color:#89dceb;font-weight:bold">&lt;</span>[WriteIDiv, ReadIDiv, ReadIDiv]<span style="color:#89dceb;font-weight:bold">&gt;</span>;</span></span></code></pre></div>
<p>A write token is a <code>SchedWrite</code> TableGen instance, while a read token is a <code>SchedRead</code> instance.</p>
<p>With these <code>SchedWrite</code> and <code>SchedRead</code> tokens, a scheduling model then assigns processor-specific information to them, like <em>latency</em> and the <em>hardware resources</em> they use.</p>
<p>Take <code>SiFive7Model</code> we saw earlier as an example, in the file where the model is defined (i.e. <code>llvm/lib/Target/RISCV/RISCVSchedSiFive7.td</code>), we find this piece of snippet:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#6c7086;font-style:italic">// Integer division
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteIDiv, [SiFive7PipeB, SiFive7IDiv]<span style="color:#89dceb;font-weight:bold">&gt;</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>  let Latency <span style="color:#89dceb;font-weight:bold">=</span> <span style="color:#fab387">66</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">4</span><span>  let ReleaseAtCycles <span style="color:#89dceb;font-weight:bold">=</span> [<span style="color:#fab387">1</span>, <span style="color:#fab387">65</span>];
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">5</span><span>}</span></span></code></pre></div>
<p>The <code>WriteRes</code> TableGen class<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup> takes a <code>SchedWrite</code> &ndash; in this case <code>WriteIDIV</code> &ndash; and assigns it three different kinds of information:</p>
<ul>
<li>Latency of 66 cycles</li>
<li>The hardware resources it uses: <code>SiFive7PipeB</code> and <code>SiFive7IDiv</code></li>
<li>The <code>ReleaseAtCycles</code> field specifies the number of cycles this instruction spends on each hardware resource it uses. In this case, <code>WriteIDIV</code> spends 1 cycle on <code>SiFive7PipeB</code> and 65 cycles on <code>SiFive7IDiv</code></li>
</ul>
<p>What about <code>ReadIDIV</code>, the <code>SchedRead</code> instances we saw earlier? By default, LLVM&rsquo;s scheduling model assumes that operand reads finish instantly, so a <code>SchedRead</code> cannot be assigned a latency property nor consuming any cycle the same way as a <code>SchedWrite</code>.</p>
<p>Which means that effectively, write operands dictate the instruction&rsquo;s scheduling properties and it&rsquo;s expected to represent majority of the changes an instruction makes to the processor states. So, it&rsquo;s safe to say that in this case, an <code>DIV</code> instruction has a latency of 66 cycles.</p>
<p>Alright, so far we have covered the most basic part of a scheduling model, specifically on how to specify the scheduling information for an instruction. We can summarize it into three quick steps:</p>
<ol>
<li>Assigning <code>SchedRead</code> and <code>SchedWrite</code> to your instruction</li>
<li>In your scheduling model, find the processor resources <code>SchedWrite</code> use&hellip;</li>
<li>&hellip;and map those resources to <code>SchedWrite</code> using <code>WriteRes</code>, along with other info like latency.</li>
</ol>
<p>I have intentionally left many details aside, like what exactly is a hardware resource (e.g <code>SiFive7PipeB</code>). These details are strongly related to what we&rsquo;re going to cover in the next section: the <strong>microarchitecture</strong> of a processor.</p>
<h3 id="modeling-microarchitecture">Modeling microarchitecture</h3>
<p>Recall the goals of instruction scheduling are to minimize latency, maximize throughput, and eliminate as many potential hazards in the processor&rsquo;s pipeline as possible.
These goals have a lot to do with how instructions <em>move</em> within the processor&rsquo;s pipeline. For instance, extra cycles might be spent on fulfilling RAW (Read after Write) data dependencies, or certain units, like an integer division unit, might be overwhelmed and stall the entire pipeline.</p>
<p>And this is where the processor&rsquo;s microarchitecture comes into play. Specifically, we&rsquo;re focusing on <strong>superscalar</strong> architecture here, which has a typical structure shown below:</p>
<div style="text-align: center;">
  <picture>
    <source srcset="/images/llvm-sched-model-basic-superscalar.dark.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/llvm-sched-model-basic-superscalar.light.svg">
  </picture>
</div>
<p>The above structure has an issue width of 3, meaning it can feed at most 3 instructions to later stages at a time; micro-codes, or <em>uops</em>, are generated at the decode stage; at this moment we&rsquo;re a little hand-waving on the definition of dispatch and issue, as we&rsquo;ll see several of their variants later; there are three different <strong>functional units</strong> in the execution stage for integer, floating point, and memory instructions (load / store unit). All of them are fully pipelined.</p>
<p>Despite the fact that scheduling model has strong connections with microarchitectures, we don&rsquo;t want our model to cover <em>too</em> many microarchitecture details &ndash; it&rsquo;s simply too expensive! What we want is a model that can raise red flags when we come up with a bad scheduling, yet abstract away all the nitty-gritty details and present just the information we care.</p>
<p>&ldquo;What kind of red flags?&rdquo; you may ask. The most important thing is probably whether we have enough <em>resources</em> to even run an instruction. Remember, the whole idea of superscalar is to run instructions of different types in different function units <strong>in parallel</strong>: integer uops go into integer units and floating point uops go into another floating point unit, where these units can run independently.
Each of these units has one or more <em>pipes</em> that actually run the uops. In many places &ldquo;functional units&rdquo; and &ldquo;pipes&rdquo; are interchangable.
If there is no enough resource, we won&rsquo;t be able to <strong>dispatch</strong> an uop into any of the pipes. After all, processors have only a limited number of pipes for a specific type of instructions.</p>
<p>Let&rsquo;s look at a concrete example: SiFive&rsquo;s P670 RISC-V processor.</p>
<figure style="text-align: center;">
  <img src="/images/p670-uarch.png">
  <figcaption>Image source: <a href="https://www.cnx-software.com/2022/11/02/sifive-p670-and-p470-risc-v-processors-add-risc-v-vector-extensions/">CNX software</a></figcaption>
</figure>
<p>P670 is an out-of-order processor targeting consumer devices like smartphones. It has four integer pipes, two floating point pipes, and two vector units. And this is how integer pipes look like in its <a href="https://github.com/llvm/llvm-project/blob/e70f376b25ea96f3b0db75ff77ae1a58d53f2119/llvm/lib/Target/RISC/RISCVSchedSiFiveP600.td">scheduling model</a>:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span>def <span style="color:#89dceb">SiFiveP600IEXQ0</span>       : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">1</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>def <span style="color:#89dceb">SiFiveP600IEXQ1</span>       : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">1</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>def <span style="color:#89dceb">SiFiveP600IEXQ2</span>       : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">1</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">4</span><span>def <span style="color:#89dceb">SiFiveP600IEXQ3</span>       : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">1</span><span style="color:#89dceb;font-weight:bold">&gt;</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">5</span><span>...
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">6</span><span>def <span style="color:#89dceb">SiFiveP600IntArith</span>    : ProcResGroup<span style="color:#89dceb;font-weight:bold">&lt;</span>[SiFiveP600IEXQ0, SiFiveP600IEXQ1, SiFiveP600IEXQ2, SiFiveP600IEXQ3]<span style="color:#89dceb;font-weight:bold">&gt;</span>;</span></span></code></pre></div>
<p>In LLVM, a <code>ProcResource</code> instance in TableGen represents a unit that can executes uops, hence an equivalent to a single pipe in most cases. Here, each integer pipe in P600 is represented by <code>SiFiveP600IEXQ[0-3]</code></p>
<p>Nevertheless, it&rsquo;s not the only instance you can <em>dispatch</em> uops to, because sometimes you can dispatch uops into a collection of pipes in which <em>any</em> of the pipes in that group can execute the dispatched uop. Such groups are represented by <code>ProcResGroup</code> instances in TableGen, like the <code>SiFiveP600IntArith</code> we see above: when an instruction &ndash; like <code>ADD</code> who uses <code>WriteIALU</code> &ndash; <a href="https://github.com/llvm/llvm-project/blob/fdb9f96fa2a926425bdf8315048db7623d63547d/llvm/lib/Target/RISCV/RISCVSchedSiFiveP600.td#L104">consumes</a> a <code>SiFiveP600IntArith</code> shown in the snippet below, it means that such instruction can be dispatched to any of the <code>SiFiveP600IEXQ[0-3]</code>.</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#6c7086;font-style:italic">// Integer arithmetic and logic
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89dceb">def</span> : WriteRes<span style="color:#89dceb;font-weight:bold">&lt;</span>WriteIALU, [SiFiveP600IntArith]<span style="color:#89dceb;font-weight:bold">&gt;</span>;</span></span></code></pre></div>
<p>When there is no available pipe, a stall or a hazard occurs, in this case it is considered a <em>dispatch</em> hazard since you can&rsquo;t dispatch more instructions. To avoid such hazards, each pipe usually has a buffer or a queue to store a certain number of candidates. Knowing the <strong>size</strong> of that buffer is crucial to our scheduling model, because then we can make a wiser decision on distributing the instructions <em>evenly</em> across all pipes, rather than jamming them into a single one just like freeways in LA.</p>
<p>Most<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup> processors with buffers / queues like this have a more well-known functionality: reordering instructions. In an our-of-order processor, each of these buffers is used as some sort of staging area for the scheduler to preemptively <strong>issue</strong> instructions with no dependencies on the others, in the hope of hiding latencies.</p>
<p>Aside from the size of the buffer, how to <em>organize</em> these buffers (e.g. several pipes might share a buffer) is just as important as their sizes. In the next section, we&rsquo;re gonna go through processor resource buffers of different sizes and layouts.</p>
<h4 id="processor-resource-buffers">Processor resource buffers</h4>
<p>Let&rsquo;s sort out some terminologies first. The buffer, or <strong>scheduler queue</strong> we&rsquo;re talking about here, is often known as a <strong>reservation station</strong> too.
Reservation station stores instructions whose <em>operands</em> might not be ready yet, until those operands are available. <strong>Reorder buffer (ROB)</strong>, on the other hand, is a kind of unit with slightly confusing name. ROB reorders the <em>results</em> of an instruction; it&rsquo;s usually depicted at the end of the execution stage, as shown in the previous diagram. Nevertheless, we need to reserve a slot in the ROB <em>before</em> we can even dispatch an instruction, therefore, to some extent, the size of ROB also controls how many instructions are allowed into the execution stage.</p>
<p>Back to the buffers, in LLVM&rsquo;s scheduling model, we use the <code>BufferSize</code> field in a <code>ProcessorResource</code> or a <code>ProcResGroup</code> instance to specify the size of the associated buffer.
Special values are also used to denote unconventional buffer layouts, or even the <em>absent</em> of buffers.</p>
<p>LLVM currently supports 4 different kinds of buffer layouts: decoupled reservation stations, unified reservation station, in-order core, and latency device. Let&rsquo;s go through each of them now.</p>
<h5 id="decoupled-reservation-stations">Decoupled reservation stations</h5>
<div style="text-align: center;">
  <picture>
    <source srcset="/images/llvm-sched-model-decoupled-reservation-stations.dark.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/llvm-sched-model-decoupled-reservation-stations.light.svg">
  </picture>
</div>
<p>When we assign a <strong>positive</strong> <code>BufferSize</code> to individual processor resources or processor resource groups, we&rsquo;re modeling processor resources with their own scheduler queues. Here is an example from PowerPC POWER9&rsquo;s <a href="https://github.com/llvm/llvm-project/blob/22c06aa5e94e30fb1333ecaf46ce33c65d148634/llvm/lib/Target/PowerPC/PPCScheduleP9.td#L123">scheduling model</a>:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#6c7086;font-style:italic">// Only one Branch unit.
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span><span style="color:#6c7086;font-style:italic"></span>def <span style="color:#89dceb">BR</span> : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">1</span><span style="color:#89dceb;font-weight:bold">&gt;</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>  let BufferSize <span style="color:#89dceb;font-weight:bold">=</span> <span style="color:#fab387">16</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">4</span><span>}</span></span></code></pre></div>
<p>Here, the execution unit for branch instructions has its own scheduler and it has 16 entries in its buffer.</p>
<p>A more common arrangement is assigning <code>BufferSize</code> on a processor resource <em>group</em>.
For instance, in AMD Zen2 CPU, there are total of 4 general integer execution units with their own schedulers; each scheduler has 16 buffer entries.</p>
<figure style="text-align: center;">
  <img src="/images/zen2-uarch.svg">
  <figcaption>Image source: <a href="https://en.wikichip.org/wiki/amd/microarchitectures/zen_2">Wiki Chip</a></figcaption>
</figure>
<p>In Zen2&rsquo;s LLVM scheduling model, these schedulers are represented by 4 <code>ProcessorResource</code> instances: <code>Zn2ALU[0-3]</code>.
Despite the fact that there are 4 separate schedulers in real hardware, Zen2&rsquo; scheduling model doesn&rsquo;t assign <code>BufferSize = 16</code> to each <code>Zn2ALU[0-3]</code> instance, but instead group all 4 instances into a single <code>ProcResGroup</code> called <code>Zn2ALU</code> and <a href="https://github.com/llvm/llvm-project/blob/22c06aa5e94e30fb1333ecaf46ce33c65d148634/llvm/lib/Target/X86/X86ScheduleZnver2.td#L75">assign</a> a buffer size of 16 * 4:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#6c7086;font-style:italic">// 64 Entry (16x4 entries) Int Scheduler
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span><span style="color:#6c7086;font-style:italic"></span>def <span style="color:#89dceb">Zn2ALU</span> : ProcResGroup<span style="color:#89dceb;font-weight:bold">&lt;</span>[Zn2ALU0, Zn2ALU1, Zn2ALU2, Zn2ALU3]<span style="color:#89dceb;font-weight:bold">&gt;</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>  let BufferSize<span style="color:#89dceb;font-weight:bold">=</span><span style="color:#fab387">64</span>;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">4</span><span>}</span></span></code></pre></div>
<p>The rationale behind this is that most integer instructions map <code>Zn2ALU</code>, rather than a specific <code>Zn2ALU[0-3]</code>, to their <code>SchedWrite</code> token. Because similar to the SiFive P600 example we&rsquo;ve seen earlier, these instructions simply don&rsquo;t care which <code>Zn2ALU[0-3]</code> they are going to run on. Therefore, it makes more sense to specify the buffer size on the processor resource group.</p>
<h5 id="unified-reservation-station">Unified reservation station</h5>
<p>By default, <code>BufferSize</code> is set to <strong>-1</strong>, representing a layout where all the processor resources effectively share the same buffer as illustrated in the diagram below.</p>
<div style="text-align: center;">
  <picture>
    <source srcset="/images/llvm-sched-model-unified-reservation-station.dark.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/llvm-sched-model-unified-reservation-station.light.svg">
  </picture>
</div>
<p>In this case, the actual size of such buffer is dictated by <code>MicroOpBufferSize</code>, which is a global attribute to the entire scheduling model rather than individual processor resource:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span>def <span style="color:#89dceb">SiFiveP600Model</span> : SchedMachineModel {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>  let IssueWidth <span style="color:#89dceb;font-weight:bold">=</span> <span style="color:#fab387">4</span>;         <span style="color:#6c7086;font-style:italic">// 4 micro-ops are dispatched per cycle.
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span><span style="color:#6c7086;font-style:italic"></span>  let MicroOpBufferSize <span style="color:#89dceb;font-weight:bold">=</span> <span style="color:#fab387">160</span>; <span style="color:#6c7086;font-style:italic">// Max micro-ops that can be buffered.
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">4</span><span><span style="color:#6c7086;font-style:italic"></span>  ...
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">5</span><span>}</span></span></code></pre></div>
<p>This <code>MicroOpBufferSize</code> attribute is primarily used to throttle the number of uops to be <em>dispatched</em>. There are, however, many factors that control this throttle at the same time. Notably, ROB and register renaming. We&rsquo;ve explained the effect of ROB earlier; for register renaming, if there aren&rsquo;t enough physical registers for us to rename, a dispatch hazard also occurs. Consequently, the value of <code>MicroOpBufferSize</code> should be the minimal of reorder buffer size, size of register renaming pool, and the actual size of unified reservation station.</p>
<h5 id="in-order-core">In-order core</h5>
<p>So far we have been discussing out-of-order cores, which is one of the primary reasons why we need buffers in the first place. But in-order cores are still a thing, because it dramatically simplifies the chip design and reduces the area, which are top on the list for products like embedded devices. It&rsquo;s also getting more popular in cases where you want save areas for specialized units like BIG vector units or even matrix multiplication units. SiFive&rsquo;s X280, which we&rsquo;ve seen its scheduling model previously, and X390 are good examples, where they save area by adopting in-order design and enjoying a whopping 512- and 1024-bit vector, respectively.</p>
<p>For in-order cores, you simply set <code>BufferSize</code> and <code>MicroOpBufferSize</code> mentioned earlier to <strong>zero</strong>.
When an uop is handed to an in-order unit in LLVM&rsquo;s scheduling model, <em>dispatch</em> and <em>issue</em> are considered happening at the same time.</p>
<div style="text-align: center;">
  <picture>
    <source srcset="/images/llvm-sched-model-in-order.dark.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/llvm-sched-model-in-order.light.svg">
  </picture>
</div>
<p>The uop then holds the processor resource until <code>ReleaseAtCycle</code> before another uop can be dispatched. In other words, the younger uop would encounter a dispatch hazard until <code>ReleaseAtCycle</code> has passed in the older uop.</p>
<h5 id="latency-device">Latency device</h5>
<p>When <code>BufferSize</code> equals to 1, we create a unique kind of resource known as latency device. Resources of this kind act just like an in-order pipeline, except two things:</p>
<ol>
<li>Since there is still a buffer, albeit being a really small one, a younger uop waits in the buffer until the older uop finishes, rather than encounters a dispatch hazard.</li>
<li>LLVM&rsquo;s instruction scheduler always treats two adjacent uops that use this resource as producer and consumer (even if there is no data dependency between them). Meaning, the younger uop always waits <code>Latency</code> cycles after the old uop was issued &ndash; as opposed to waiting until <code>ReleaseAtCycle</code> has passed in a normal in-order pipeline &ndash; before it can be issued.</li>
</ol>
<p>This kind of resource was designed to model in-order units within an out-of-order core. It&rsquo;s most commonly used for modeling <strong>un-pipelined</strong> units nowadays (which, of course, is in-order). Yes, it&rsquo;s 2024 and there are still computations that are difficult to be pipelined, most notably integer &ndash; sometimes even floating point &ndash; <em>divisions</em>. It is possible to make integer divisions pipelined, but many of the times it&rsquo;s not worth the chip area.</p>
<div style="text-align: center;">
  <picture>
    <source srcset="/images/llvm-sched-model-latency-device.dark.svg" media="(prefers-color-scheme: dark)">
    <img src="/images/llvm-sched-model-latency-device.light.svg">
  </picture>
</div>
<p>Some examples: Samsung Exynos M5&rsquo;s serialized (i.e. un-pipelined) integer division unit, represented by <code>M5UnitD</code> from <a href="https://github.com/llvm/llvm-project/blob/5262865aac683b72f3e66de7a122e0c455ab6b9b/llvm/lib/Target/AArch64/AArch64SchedExynosM5.td#L41">here</a>, has a buffer size of 1:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span>let Super <span style="color:#89dceb;font-weight:bold">=</span>  M5UnitC, BufferSize <span style="color:#89dceb;font-weight:bold">=</span> <span style="color:#fab387">1</span> in
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>def <span style="color:#89dceb">M5UnitD</span>  : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">1</span><span style="color:#89dceb;font-weight:bold">&gt;</span>; <span style="color:#6c7086;font-style:italic">// Integer division (inside C0, serialized)
</span></span></span></code></pre></div>
<p>RISC-V&rsquo;s Rocket chip <a href="https://github.com/llvm/llvm-project/blob/fdb9f96fa2a926425bdf8315048db7623d63547d/llvm/lib/Target/RISCV/RISCVSchedRocket.td#L41">marks</a> their integer and floating point division units, <code>RocketUnitIDiv</code> and <code>RocketUnitFPDivSqrt</code>, as latency devices too:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span>let BufferSize <span style="color:#89dceb;font-weight:bold">=</span> <span style="color:#fab387">1</span> in {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>def <span style="color:#89dceb">RocketUnitIDiv</span>       : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">1</span><span style="color:#89dceb;font-weight:bold">&gt;</span>; <span style="color:#6c7086;font-style:italic">// Int Division
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span><span style="color:#6c7086;font-style:italic"></span>def <span style="color:#89dceb">RocketUnitFPDivSqrt</span>  : ProcResource<span style="color:#89dceb;font-weight:bold">&lt;</span><span style="color:#fab387">1</span><span style="color:#89dceb;font-weight:bold">&gt;</span>; <span style="color:#6c7086;font-style:italic">// FP Divide/Sqrt
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">4</span><span><span style="color:#6c7086;font-style:italic"></span>}</span></span></code></pre></div>
<h3 id="epilogue">Epilogue</h3>
<p>In this post, I went through the basics of LLVM&rsquo;s scheduling model and show how to specify the scheduling information for individual instructions. On top of that, I explained different kinds of processor resource buffers and their use cases.</p>
<p>In the next post, I will talk about <em>how</em> exactly these resource buffer kinds and latency are used in LLVM&rsquo;s instruction scheduler and LLVM MCA, as well as their performance impact on the generated code. Which helps us to make a better decision on designing new scheduling models.</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>It should have been used in more places like instruction selection and cost models in the middle end, but that&rsquo;s a story for another day.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>Interestingly, RISC-V has one of the biggest sets of opcodes. A large portion of them are pseudo instructions for RVV.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>Using <code>WriteRes</code> is not the only way to connect <code>SchedWrite</code> with processor resources. I might talk about an alternative that involves <code>InstRW</code> and <code>SchedWriteRes</code> in future posts.&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p>Superscalar and out-of-order-ness are two independent concepts. Superscalar is about increasing the &ldquo;width&rdquo; of your execution units; out-of-order is about the order of executions. You can have in-order superscalar processors, which are pretty common, as well as out-of-order non-superscalar processors, which barely exist but no one can stop you from making it.&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded></item><item><title>Legalizations in LLVM Backend</title><link>https://myhsu.xyz/llvm-codegen-legalization/</link><pubDate>Wed, 15 May 2024 00:00:00 +0000</pubDate><author>min@myhsu.dev (Min-Yih Hsu)</author><guid>https://myhsu.xyz/llvm-codegen-legalization/</guid><description>Ideally, compilers can build a program for a wide variety of hardware without the need to change a single line of its source code. While there are exceptions and corner cases, this holds in the majority of cases. Which means that if the input code uses something that is not directly available on the hardware, the compiler has to figure out a way to effectively emulate those features.
This might sound a little distant to our typical software development experiences, but I&amp;rsquo;m not even talking about a problem that only happens on some exotic proprietary ML accelerator whatnots.</description><content:encoded><![CDATA[<p>Ideally, compilers can build a program for a wide variety of hardware without the need to change a single line of its source code.
While there are exceptions and corner cases, this holds in the majority of cases.
Which means that if the input code uses something that is not directly available on the hardware, the compiler has to figure out a way to effectively <em>emulate</em> those
features.</p>
<p>This might sound a little distant to our typical software development experiences, but I&rsquo;m not even talking about a problem that only happens on some exotic proprietary ML accelerator whatnots. There is a good
example of this regarding something you use almost everyday: <strong>boolean variables</strong>.
I&rsquo;m pretty sure none of the modern processors provides 1-bit registers<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> (or addressable memory space), yet we still use boolean variables extensively.
Other common examples include the lack of double-precision floating point operations, or even lacks floating point unit altogether in some embedded devices.</p>
<p>The process that &ldquo;reshapes&rdquo; input programs into using what&rsquo;s available on the target hardware is called <strong>legalization</strong> in LLVM<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>, and it&rsquo;s done in LLVM&rsquo;s code generation (codegen)
pipeline a.k.a the <strong>backend</strong>.
In this post, I&rsquo;m going to give an overview on how it works.</p>
<h3 id="a-sneak-peek-into-selectiondag-isel">A sneak peek into SelectionDAG ISel</h3>
<p>LLVM&rsquo;s codegen pipeline in the backend is consisted of LLVM Passes, same as the middle-end<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup>. This long long pipeline is usually partitioned by important events like register allocation and instruction scheduling, and the
legalization happens around one of the earlier events, the instruction selection (ISel).</p>
<p>Several different ISel strategies co-existing in LLVM at this moment. Here, we&rsquo;re focusing on <strong>SelectionDAG ISel</strong> first, which is the primary one implemented by every targets.
This ISel turns instructions in each basic block into a DAG, different from the &ldquo;linear&rdquo; representation of instructions as we seen in LLVM IR.</p>
<p>We can roughly divide SelectionDAG ISel further into 4 steps, they are:</p>
<ol>
<li>Building SelectionDAG</li>
<li>Type legalization</li>
<li>Legalizing operations</li>
<li>Instruction selection</li>
</ol>
<p>There are actually lots of going on in between the steps, like optimizing the DAG (by DAGCombiner) and LegalizeVectorOps in the presence of vectors (which should really be called &ldquo;scalarize vector ops&rdquo;). But in any case, legalization is primarily consist of two separate steps, type legalization and legalizing the operations (i.e. instructions). Let&rsquo;s cover these two in order.</p>
<h3 id="type-legalization">Type legalization</h3>
<p>Type legalization tries to turn unsupported types into the ones supported by the target architecture. To give you a better idea on how this works in action, let&rsquo;s send the following
LLVM IR snippet into SelectionDAG ISel and see how it got legalized.</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-llvm" data-lang="llvm"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#cba6f7">define</span> <span style="color:#cba6f7">i32</span> <span style="color:#f5e0dc">@foo</span>(<span style="color:#cba6f7">i32</span> <span style="color:#f5e0dc">%v</span>) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>  <span style="color:#f5e0dc">%lo</span> = <span style="color:#cba6f7">trunc</span> <span style="color:#cba6f7">i32</span> <span style="color:#f5e0dc">%v</span> <span style="color:#cba6f7">to</span> <span style="color:#cba6f7">i16</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>  <span style="color:#f5e0dc">%p</span> = <span style="color:#cba6f7">add</span> <span style="color:#cba6f7">i16</span> <span style="color:#f5e0dc">%lo</span>, <span style="color:#fab387">5</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">4</span><span>  <span style="color:#f5e0dc">%c</span> = <span style="color:#cba6f7">icmp</span> <span style="color:#cba6f7">ugt</span> <span style="color:#cba6f7">i16</span> <span style="color:#f5e0dc">%p</span>, <span style="color:#fab387">6</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">5</span><span>  <span style="color:#f5e0dc">%r</span> = <span style="color:#cba6f7">select</span> <span style="color:#cba6f7">i1</span> <span style="color:#f5e0dc">%c</span>, <span style="color:#cba6f7">i32</span> <span style="color:#f5e0dc">%v</span>, <span style="color:#cba6f7">i32</span> <span style="color:#fab387">9</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">6</span><span>  <span style="color:#cba6f7">ret</span> <span style="color:#cba6f7">i32</span> <span style="color:#f5e0dc">%r</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">7</span><span>}</span></span></code></pre></div>
<p>In order to print the trace of SelectionDAG ISel, please follow the instructions here to make sure the tool we&rsquo;re about to use, <code>llc</code>, has the right capability.</p>
<details >
  <summary>Notes on llc</summary>
<p>Printing the trace of SelectionDAG ISel requires either a debug build of LLVM or an LLVM with assertions enabled. Unfortunately, prebuilt LLVM provided by major Linux / BSD / MacOSX
distributions meet none of the requirements. So you might have to build LLVM from source.</p>
<ol>
<li>Please checkout the build instructions <a href="https://llvm.org/docs/CMake.html#quick-start">here</a></li>
<li>During cmake configuration phase, either you set it to debug build by passing <code>-DCMAKE_BUILD_TYPE=Debug</code>, or passes <code>-DLLVM_ENABLE_ASSERTIONS=ON</code> to enable assertions on a release build</li>
<li>We&rsquo;re about to use RISC-V as the target throughput the examples in this post, please make sure it&rsquo;s built, which is the default.</li>
<li>Run <code>cmake --build . --target llc</code> to build only the <code>llc</code>.</li>
</ol>
</details>
Then, please run the following command with `input.ll` being the snippet we saw previously.
<details >
  <summary>llc command</summary>
<p><code>llc -mtriple riscv32 -debug-only=isel-dump input.ll -o /dev/null</code></p>
</details>
<p>You&rsquo;ll see an output partitioned into several sections, starting with sentences like <em>&ldquo;Initial selection DAG: &hellip;&rdquo;</em> or <em>&ldquo;Optimized lowered selection DAG: &hellip;&rdquo;</em></p>






<pre tabindex="0"><code>Initial selection DAG: %bb.0 &#39;foo:&#39;
...
Optimized lowered selection DAG: %bb.0 &#39;foo:&#39;
...
Type-legalized selection DAG: %bb.0 &#39;foo:&#39;
...
Optimized type-legalized selection DAG: %bb.0 &#39;foo:&#39;
...
Legalized selection DAG: %bb.0 &#39;foo:&#39;
...
Optimized legalized selection DAG: %bb.0 &#39;foo:&#39;
...
Selected selection DAG: %bb.0 &#39;foo:&#39;
...</code></pre>
<p>These sections correspond to the 4 steps we&rsquo;ve discussed previously. Each of these section shows the SelectionDAG after the step, like this:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-llvm" data-lang="llvm"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 1</span><span><span style="color:#f38ba8">Initial</span> <span style="color:#f38ba8">selection</span> <span style="color:#89dceb">DAG:</span> <span style="color:#f5e0dc">%bb.0</span> <span style="color:#f38ba8">&#39;</span><span style="color:#89dceb">foo:</span><span style="color:#f38ba8">&#39;</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 2</span><span><span style="color:#f38ba8">SelectionDAG</span> <span style="color:#f38ba8">has</span> <span style="color:#fab387">14</span> <span style="color:#89dceb">nodes:</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 3</span><span>  <span style="color:#89dceb">t0:</span> <span style="color:#f38ba8">ch</span>,<span style="color:#f38ba8">glue</span> = <span style="color:#f38ba8">EntryToken</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 4</span><span>  <span style="color:#89dceb">t2:</span> <span style="color:#cba6f7">i32</span>,<span style="color:#f38ba8">ch</span> = <span style="color:#f38ba8">CopyFromReg</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">0</span>, <span style="color:#89dceb">Register:</span><span style="color:#cba6f7">i32</span> %0
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 5</span><span>          <span style="color:#89dceb">t3:</span> <span style="color:#cba6f7">i16</span> = <span style="color:#f38ba8">truncate</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">2</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 6</span><span>        <span style="color:#89dceb">t5:</span> <span style="color:#cba6f7">i16</span> = <span style="color:#cba6f7">add</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">3</span>, <span style="color:#89dceb">Constant:</span><span style="color:#cba6f7">i16</span>&lt;<span style="color:#fab387">5</span>&gt;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 7</span><span>      <span style="color:#89dceb">t8:</span> <span style="color:#cba6f7">i1</span> = <span style="color:#f38ba8">set</span><span style="color:#cba6f7">cc</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">5</span>, <span style="color:#89dceb">Constant:</span><span style="color:#cba6f7">i16</span>&lt;<span style="color:#fab387">6</span>&gt;, <span style="color:#89dceb">setugt:</span><span style="color:#f38ba8">ch</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 8</span><span>    <span style="color:#89dceb">t10:</span> <span style="color:#cba6f7">i32</span> = <span style="color:#cba6f7">select</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">8</span>, <span style="color:#f38ba8">t</span><span style="color:#fab387">2</span>, <span style="color:#89dceb">Constant:</span><span style="color:#cba6f7">i32</span>&lt;<span style="color:#fab387">9</span>&gt;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 9</span><span>  <span style="color:#89dceb">t12:</span> <span style="color:#f38ba8">ch</span>,<span style="color:#f38ba8">glue</span> = <span style="color:#f38ba8">CopyToReg</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">0</span>, <span style="color:#89dceb">Register:</span><span style="color:#cba6f7">i32</span> <span style="color:#f38ba8">$x</span><span style="color:#fab387">10</span>, <span style="color:#f38ba8">t</span><span style="color:#fab387">10</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">10</span><span>  <span style="color:#89dceb">t13:</span> <span style="color:#f38ba8">ch</span> = <span style="color:#89dceb">RISCVISD:</span><span style="color:#f38ba8">:RET_GLUE</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">12</span>, <span style="color:#89dceb">Register:</span><span style="color:#cba6f7">i32</span> <span style="color:#f38ba8">$x</span><span style="color:#fab387">10</span>, <span style="color:#89dceb">t12:</span><span style="color:#fab387">1</span></span></span></code></pre></div>
<p>Again, we&rsquo;re not going into details of the DAG. But here are some quick primers on reading this DAG:</p>
<details >
  <summary>How to read SelectionDAG in 30 seconds or less</summary>
<ul>
<li>SelectionDAG stills keeps the SSA form, so an operation like <code>t3: i16 = truncate t2</code> defines value <code>t3</code>, which is used by <code>t5: i16 = add t3, Constant:i16&lt;5&gt;</code> as its first operand</li>
<li><code>t3: i16</code> means that value <code>t3</code> has a 16-bit integer type
<ul>
<li>Don&rsquo;t worry about types like <code>ch</code> (chain) and <code>glue</code>. They&rsquo;re used to express dependencies stem from control flow or side effects.</li>
</ul>
</li>
<li>Most of the operations here, like <code>truncate</code>, <code>add</code>, and <code>select</code> are pretty easy to understand. <code>setcc</code> is basically a comparison operation, which compares its first and second operand (in this case <code>t5</code> and constant 6) according to the conditional code in the third operand(in this case <code>setugt</code> &ndash; unsigned greater than). <code>CopyFromReg</code>, as its name suggested, copies values from a certain physical register to a value like <code>t2</code>.
<ul>
<li>Don&rsquo;t worry about the rest of the operations like <code>RISCVISD::RET_GLUE</code>. We&rsquo;re not going to need them here</li>
</ul>
</li>
</ul>
</details>
<p>What we&rsquo;re really interested in here is the differences before and after the type legalization step.
Here is the DAG before:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-llvm" data-lang="llvm"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 1</span><span><span style="color:#f38ba8">Optimized</span> <span style="color:#f38ba8">lowered</span> <span style="color:#f38ba8">selection</span> <span style="color:#89dceb">DAG:</span> <span style="color:#f5e0dc">%bb.0</span> <span style="color:#f38ba8">&#39;</span><span style="color:#89dceb">foo:</span><span style="color:#f38ba8">&#39;</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 2</span><span><span style="color:#f38ba8">SelectionDAG</span> <span style="color:#f38ba8">has</span> <span style="color:#fab387">14</span> <span style="color:#89dceb">nodes:</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 3</span><span>  <span style="color:#89dceb">t0:</span> <span style="color:#f38ba8">ch</span>,<span style="color:#f38ba8">glue</span> = <span style="color:#f38ba8">EntryToken</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 4</span><span>  <span style="color:#89dceb">t2:</span> <span style="color:#cba6f7">i32</span>,<span style="color:#f38ba8">ch</span> = <span style="color:#f38ba8">CopyFromReg</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">0</span>, <span style="color:#89dceb">Register:</span><span style="color:#cba6f7">i32</span> %0
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 5</span><span>          <span style="color:#89dceb">t3:</span> <span style="color:#cba6f7">i16</span> = <span style="color:#f38ba8">truncate</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">2</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 6</span><span>        <span style="color:#89dceb">t5:</span> <span style="color:#cba6f7">i16</span> = <span style="color:#cba6f7">add</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">3</span>, <span style="color:#89dceb">Constant:</span><span style="color:#cba6f7">i16</span>&lt;<span style="color:#fab387">5</span>&gt;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 7</span><span>      <span style="color:#89dceb">t8:</span> <span style="color:#cba6f7">i1</span> = <span style="color:#f38ba8">set</span><span style="color:#cba6f7">cc</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">5</span>, <span style="color:#89dceb">Constant:</span><span style="color:#cba6f7">i16</span>&lt;<span style="color:#fab387">6</span>&gt;, <span style="color:#89dceb">setugt:</span><span style="color:#f38ba8">ch</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 8</span><span>    <span style="color:#89dceb">t10:</span> <span style="color:#cba6f7">i32</span> = <span style="color:#cba6f7">select</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">8</span>, <span style="color:#f38ba8">t</span><span style="color:#fab387">2</span>, <span style="color:#89dceb">Constant:</span><span style="color:#cba6f7">i32</span>&lt;<span style="color:#fab387">9</span>&gt;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 9</span><span>  <span style="color:#89dceb">t12:</span> <span style="color:#f38ba8">ch</span>,<span style="color:#f38ba8">glue</span> = <span style="color:#f38ba8">CopyToReg</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">0</span>, <span style="color:#89dceb">Register:</span><span style="color:#cba6f7">i32</span> <span style="color:#f38ba8">$x</span><span style="color:#fab387">10</span>, <span style="color:#f38ba8">t</span><span style="color:#fab387">10</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">10</span><span>  <span style="color:#89dceb">t13:</span> <span style="color:#f38ba8">ch</span> = <span style="color:#89dceb">RISCVISD:</span><span style="color:#f38ba8">:RET_GLUE</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">12</span>, <span style="color:#89dceb">Register:</span><span style="color:#cba6f7">i32</span> <span style="color:#f38ba8">$x</span><span style="color:#fab387">10</span>, <span style="color:#89dceb">t12:</span><span style="color:#fab387">1</span></span></span></code></pre></div>
<p>And this is the type-legalized DAG:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-llvm" data-lang="llvm"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 1</span><span><span style="color:#f38ba8">Type-legalized</span> <span style="color:#f38ba8">selection</span> <span style="color:#89dceb">DAG:</span> <span style="color:#f5e0dc">%bb.0</span> <span style="color:#f38ba8">&#39;</span><span style="color:#89dceb">foo:</span><span style="color:#f38ba8">&#39;</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 2</span><span><span style="color:#f38ba8">SelectionDAG</span> <span style="color:#f38ba8">has</span> <span style="color:#fab387">17</span> <span style="color:#89dceb">nodes:</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 3</span><span>  <span style="color:#89dceb">t0:</span> <span style="color:#f38ba8">ch</span>,<span style="color:#f38ba8">glue</span> = <span style="color:#f38ba8">EntryToken</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 4</span><span>  <span style="color:#89dceb">t2:</span> <span style="color:#cba6f7">i32</span>,<span style="color:#f38ba8">ch</span> = <span style="color:#f38ba8">CopyFromReg</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">0</span>, <span style="color:#89dceb">Register:</span><span style="color:#cba6f7">i32</span> %0
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 5</span><span>            <span style="color:#89dceb">t16:</span> <span style="color:#cba6f7">i32</span> = <span style="color:#cba6f7">add</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">2</span>, <span style="color:#89dceb">Constant:</span><span style="color:#cba6f7">i32</span>&lt;<span style="color:#fab387">5</span>&gt;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 6</span><span>          <span style="color:#89dceb">t22:</span> <span style="color:#cba6f7">i32</span> = <span style="color:#cba6f7">and</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">16</span>, <span style="color:#89dceb">Constant:</span><span style="color:#cba6f7">i32</span>&lt;<span style="color:#fab387">65535</span>&gt;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 7</span><span>        <span style="color:#89dceb">t17:</span> <span style="color:#cba6f7">i32</span> = <span style="color:#f38ba8">set</span><span style="color:#cba6f7">cc</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">22</span>, <span style="color:#89dceb">Constant:</span><span style="color:#cba6f7">i32</span>&lt;<span style="color:#fab387">6</span>&gt;, <span style="color:#89dceb">setugt:</span><span style="color:#f38ba8">ch</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 8</span><span>      <span style="color:#89dceb">t20:</span> <span style="color:#cba6f7">i32</span> = <span style="color:#cba6f7">and</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">17</span>, <span style="color:#89dceb">Constant:</span><span style="color:#cba6f7">i32</span>&lt;<span style="color:#fab387">1</span>&gt;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c"> 9</span><span>    <span style="color:#89dceb">t10:</span> <span style="color:#cba6f7">i32</span> = <span style="color:#cba6f7">select</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">20</span>, <span style="color:#f38ba8">t</span><span style="color:#fab387">2</span>, <span style="color:#89dceb">Constant:</span><span style="color:#cba6f7">i32</span>&lt;<span style="color:#fab387">9</span>&gt;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">10</span><span>  <span style="color:#89dceb">t12:</span> <span style="color:#f38ba8">ch</span>,<span style="color:#f38ba8">glue</span> = <span style="color:#f38ba8">CopyToReg</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">0</span>, <span style="color:#89dceb">Register:</span><span style="color:#cba6f7">i32</span> <span style="color:#f38ba8">$x</span><span style="color:#fab387">10</span>, <span style="color:#f38ba8">t</span><span style="color:#fab387">10</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">11</span><span>  <span style="color:#89dceb">t13:</span> <span style="color:#f38ba8">ch</span> = <span style="color:#89dceb">RISCVISD:</span><span style="color:#f38ba8">:RET_GLUE</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">12</span>, <span style="color:#89dceb">Register:</span><span style="color:#cba6f7">i32</span> <span style="color:#f38ba8">$x</span><span style="color:#fab387">10</span>, <span style="color:#89dceb">t12:</span><span style="color:#fab387">1</span></span></span></code></pre></div>
<p>First, let&rsquo;s look at line 4 ~ 6 in the <strong>pre</strong>-type-legalized DAG:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-llvm" data-lang="llvm"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#89dceb">t2:</span> <span style="color:#cba6f7">i32</span>,<span style="color:#f38ba8">ch</span> = <span style="color:#f38ba8">CopyFromReg</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">0</span>, <span style="color:#89dceb">Register:</span><span style="color:#cba6f7">i32</span> %0
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>    <span style="color:#89dceb">t3:</span> <span style="color:#cba6f7">i16</span> = <span style="color:#f38ba8">truncate</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">2</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>  <span style="color:#89dceb">t5:</span> <span style="color:#cba6f7">i16</span> = <span style="color:#cba6f7">add</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">3</span>, <span style="color:#89dceb">Constant:</span><span style="color:#cba6f7">i16</span>&lt;<span style="color:#fab387">5</span>&gt;</span></span></code></pre></div>
<p>The <code>t5: i16 = add t3, Constant:i16&lt;5&gt;</code> obviously corresponds to the <code>%p = add i16 %lo, 5</code> instruction in our original LLVM IR, in which both of them are <em>16-bit</em> arithmetic summation. However, a physical register in 32-bit RISC-V (RV32) is always 32 bits, therefore after copying values from physical register <code>%0</code> via <code>CopyFromReg</code>, we have to truncate its value to 16 bits before feeding into the <code>add</code>, hence <code>t3: i16 = truncate t2</code>.</p>
<p>But wait a second, RV32 doesn&rsquo;t have any 16-bit arithmetic add instruction either! Actually, at this moment, none of the RISC-V instructions is capable of processing 16-bit data natively. That means we can never lower <code>t5: i16 = add t3, Constant:i16&lt;5&gt;</code> to a single RISC-V instruction. What we can do is <em>synthesizing</em> it with 32-bit arithmetic instructions, therefore we get this in the <strong>post</strong>-type-legalized DAG:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-llvm" data-lang="llvm"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#89dceb">t2:</span> <span style="color:#cba6f7">i32</span>,<span style="color:#f38ba8">ch</span> = <span style="color:#f38ba8">CopyFromReg</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">0</span>, <span style="color:#89dceb">Register:</span><span style="color:#cba6f7">i32</span> %0
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>    <span style="color:#89dceb">t16:</span> <span style="color:#cba6f7">i32</span> = <span style="color:#cba6f7">add</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">2</span>, <span style="color:#89dceb">Constant:</span><span style="color:#cba6f7">i32</span>&lt;<span style="color:#fab387">5</span>&gt;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>  <span style="color:#89dceb">t22:</span> <span style="color:#cba6f7">i32</span> = <span style="color:#cba6f7">and</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">16</span>, <span style="color:#89dceb">Constant:</span><span style="color:#cba6f7">i32</span>&lt;<span style="color:#fab387">65535</span>&gt;</span></span></code></pre></div>
<p><code>t22: i32 = and t16, Constant:i32&lt;65535&gt;</code> effectively zeros out the higher 16 bits in the result produced by the now-32-bit arithmetic add instruction, <code>t16: i32 = add t2, Constant:i32&lt;5&gt;</code>, which makes sure the result has the same precision as before. With this transformation, we not only ensure that all operations are only using types supported by RV32, the calculation result is also correct. In other words, we turn operations that use 16-bit integers &ndash; an <em>illegal type</em> in RISC-V &ndash; into legal ones, hence the name of type legalization.</p>
<p>Let&rsquo;s look at another similar example: line 7 and 8 in the pre-type-legalized DAG.</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-llvm" data-lang="llvm"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span>  <span style="color:#89dceb">t8:</span> <span style="color:#cba6f7">i1</span> = <span style="color:#f38ba8">set</span><span style="color:#cba6f7">cc</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">5</span>, <span style="color:#89dceb">Constant:</span><span style="color:#cba6f7">i16</span>&lt;<span style="color:#fab387">6</span>&gt;, <span style="color:#89dceb">setugt:</span><span style="color:#f38ba8">ch</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span><span style="color:#89dceb">t10:</span> <span style="color:#cba6f7">i32</span> = <span style="color:#cba6f7">select</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">8</span>, <span style="color:#f38ba8">t</span><span style="color:#fab387">2</span>, <span style="color:#89dceb">Constant:</span><span style="color:#cba6f7">i32</span>&lt;<span style="color:#fab387">9</span>&gt;</span></span></code></pre></div>
<p>As we mentioned at the beginning of this post, none of the modern processors really supports 1-bit type natively, and RISC-V is not an exception, which means 1-bit integer/boolean is considered an illegal type. Here, the type legalization did a similar thing we&rsquo;ve seen previously: turning boolean into 32-bit integers and apply a proper mask:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-llvm" data-lang="llvm"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span>    <span style="color:#89dceb">t17:</span> <span style="color:#cba6f7">i32</span> = <span style="color:#f38ba8">set</span><span style="color:#cba6f7">cc</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">22</span>, <span style="color:#89dceb">Constant:</span><span style="color:#cba6f7">i32</span>&lt;<span style="color:#fab387">6</span>&gt;, <span style="color:#89dceb">setugt:</span><span style="color:#f38ba8">ch</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>  <span style="color:#89dceb">t20:</span> <span style="color:#cba6f7">i32</span> = <span style="color:#cba6f7">and</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">17</span>, <span style="color:#89dceb">Constant:</span><span style="color:#cba6f7">i32</span>&lt;<span style="color:#fab387">1</span>&gt;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span><span style="color:#89dceb">t10:</span> <span style="color:#cba6f7">i32</span> = <span style="color:#cba6f7">select</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">20</span>, <span style="color:#f38ba8">t</span><span style="color:#fab387">2</span>, <span style="color:#89dceb">Constant:</span><span style="color:#cba6f7">i32</span>&lt;<span style="color:#fab387">9</span>&gt;</span></span></code></pre></div>
<p>The result of <code>setcc</code> is changed from <code>i1</code> to <code>i32</code>, whose higher 31 bits are cleared by the mask before feeding into the <code>select</code> operation.</p>
<h4 id="determining-legal-types-and-actions-on-illegal-types">Determining legal types and actions on illegal types</h4>
<p>So how is a type to be considered legal or illegal in a target? In LLVM, the criteria is pretty straightforward: types that can natively fit into physical register are considered legal and deemed illegal otherwise. This information is setup by a target in its TargetLowering, which is usually put in <code>XXXXISelLowering.cpp</code> where &ldquo;XXXX&rdquo; is the target name. For instance, in RISC-V, it looks like:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#6c7086;font-style:italic">// Set up the register classes.
</span></span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span><span style="color:#6c7086;font-style:italic"></span><span style="color:#89b4fa">addRegisterClass</span>(XLenVT, <span style="color:#89dceb;font-weight:bold">&amp;</span>RISCV<span style="color:#89dceb;font-weight:bold">::</span>GPRRegClass);</span></span></code></pre></div>
<p>In which <code>XLenVT</code> represents 32-bit integer in RV32 and 64-bit integer in RV64 (64-bit RISC-V). Take RV32 as an example, this line basically says that <code>GPRRegClass</code> &ndash; a group of general-purpose registers &ndash; can carry 32-bit integers. Since <code>GPRRegClass</code> is the only integer reigster class in RISC-V, 32-bit integer is the only legal integer type in RV32<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>.</p>
<p>What&rsquo;s a little more complicate is how we deal with illegal types. The type legalizer will determine the best action to turn them into legal types. What we&rsquo;ve seen earlier, turning 16-bit or 1-bit integers into 32-bit integers, is <em>promotion</em> (turning smaller types to larger ones). Other actions include expanding integer / floating point (split larger types into two smaller ones), soften floating point (turn into integer of equivalent size), split vector (cut vectors into shorter length) and widen vector (increase the vector length) etc.</p>
<p>The type legalizer has a pre-defined sequence to perform for each of these legalization actions, so a target doesn&rsquo;t really have to specify how to actually do the legalization in this part.</p>
<p>An important takeaway from type legalization is that it looks at every single value appears in the program, checks its type and tries legalizing it if needed. It doesn&rsquo;t care what <strong>operation</strong> the value came from. In other words, the concept of legal type in this phase is <em>global</em> and independent from individual operations. This is different from what we&rsquo;re going to see in legalizing operation in the next section, where individual operation has different interpretations of its own legality.</p>
<h3 id="legalizing-operations">Legalizing operations</h3>
<p>A SelectionDAG is generated from a single basic block of the source LLVM IR. Each instruction in the basic block is basically translated into a single SelectionDAG node<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup> called <code>SDNode</code>, representing an operation like <code>t16: i32 = add t2, Constant:i32&lt;5&gt;</code> we&rsquo;ve seen previously. Initially, each SDNode has a <strong>generic</strong>, target-independent opcode. In a (heavily) hand-waving analogy, a SDNode in this stage is basically an one-to-one translation from its LLVM instruction which is equally target-independent.
Nearly all of the SDNodes we&rsquo;ve seen so far in the examples, like <code>t20: i32 = and t17, Constant:i32&lt;1&gt;</code> and <code>t16: i32 = add t2, Constant:i32&lt;5&gt;</code> are SDNodes with generic opcodes<sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup>.</p>
<p>Not every of these SDNodes have its corresponding native instructions in the target hardware, though. For instance, some less-powerful processors do not natively support rotate  / funnel shifts. Meaning, in those cases we have to turn an operation rotating left by 3 bits (e.g. <code>t4: i32 = rotl t2, Constant:i32&lt;3&gt;</code>) into something else, for instance . For these targets, a <code>rotl</code> operation is considered <em>illegal</em> and we&rsquo;re <strong>legalizing</strong> such operations into supported, legal operations in the phase follows type-legalization.</p>
<details >
  <summary>What are funnel / rotate shifts</summary>
<p>Funnel shift is a special variant of bit shifting that fills in the spaces left by bits shifted away with bits from another value. It&rsquo;s a function that takes two bit sequences (e.g. integers) and a constant value specifying the number of bits to shift.
For example, given two 5-bit integers A and B:</p>






<pre tabindex="0"><code>MSB                    LSB
| A4 | A3 | A2 | A1 | A0 |
--------------------------
| B4 | B3 | B2 | B1 | B0 |</code></pre>
<p>Funnel left shift A and B by 2 bits, <code>funnel_left(A, B, 2)</code>, yields the following result:</p>






<pre tabindex="0"><code>| A2 | A1 | A0 | B4 | B3 |</code></pre>
<p>You can imagine it being A shifts left by 2 bits while the empty space in the lower bits are filled in by the higher two bits of B.</p>
<p>If A and B are identical, for instance <code>funnel_left(A, A, 2)</code>, then it becomes a <strong>rotate left</strong> operation, as it yields the following result that looks like the higher bits in A that got shifted out are &ldquo;wrapping around&rdquo; to the lower bits:</p>






<pre tabindex="0"><code>| A2 | A1 | A0 | A4 | A3 |</code></pre>
</details>
<p>In fact, since RISC-V&rsquo;s rotate instructions are optional (they are defined in Zbb and Zbkb extensions), let&rsquo;s see how RISC-V handles rotate <em>in absence of</em> native rotate instructions. Here is the input LLVM IR:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-llvm" data-lang="llvm"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#cba6f7">define</span> <span style="color:#cba6f7">i32</span> <span style="color:#f5e0dc">@foo</span>(<span style="color:#cba6f7">i32</span> <span style="color:#f5e0dc">%v</span>) {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>  <span style="color:#f5e0dc">%r</span> = <span style="color:#cba6f7">call</span> <span style="color:#cba6f7">i32</span> <span style="color:#f5e0dc">@llvm.fshl.i32</span>(<span style="color:#cba6f7">i32</span> <span style="color:#f5e0dc">%v</span>, <span style="color:#cba6f7">i32</span> <span style="color:#f5e0dc">%v</span>, <span style="color:#cba6f7">i32</span> <span style="color:#fab387">3</span>)
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>  <span style="color:#cba6f7">ret</span> <span style="color:#cba6f7">i32</span> <span style="color:#f5e0dc">%r</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">4</span><span>}</span></span></code></pre></div>
<p><code>llvm.fshl.*</code> is the <a href="https://llvm.org/docs/LangRef.html#llvm-fshl-intrinsic">intrinsic</a> for funnel left shifts.
If we use the exactly same <code>llc</code> command as earlier to compile this snippet and dump the DAGs, this is the (optimized) DAG right after type-legalization:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-llvm" data-lang="llvm"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span>  <span style="color:#89dceb">t0:</span> <span style="color:#f38ba8">ch</span>,<span style="color:#f38ba8">glue</span> = <span style="color:#f38ba8">EntryToken</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>      <span style="color:#89dceb">t2:</span> <span style="color:#cba6f7">i32</span>,<span style="color:#f38ba8">ch</span> = <span style="color:#f38ba8">CopyFromReg</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">0</span>, <span style="color:#89dceb">Register:</span><span style="color:#cba6f7">i32</span> %0
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>    <span style="color:#89dceb">t4:</span> <span style="color:#cba6f7">i32</span> = <span style="color:#f38ba8">rotl</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">2</span>, <span style="color:#89dceb">Constant:</span><span style="color:#cba6f7">i32</span>&lt;<span style="color:#fab387">3</span>&gt;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">4</span><span>  <span style="color:#89dceb">t6:</span> <span style="color:#f38ba8">ch</span>,<span style="color:#f38ba8">glue</span> = <span style="color:#f38ba8">CopyToReg</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">0</span>, <span style="color:#89dceb">Register:</span><span style="color:#cba6f7">i32</span> <span style="color:#f38ba8">$x</span><span style="color:#fab387">10</span>, <span style="color:#f38ba8">t</span><span style="color:#fab387">4</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">5</span><span>  <span style="color:#89dceb">t7:</span> <span style="color:#f38ba8">ch</span> = <span style="color:#89dceb">RISCVISD:</span><span style="color:#f38ba8">:RET_GLUE</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">6</span>, <span style="color:#89dceb">Register:</span><span style="color:#cba6f7">i32</span> <span style="color:#f38ba8">$x</span><span style="color:#fab387">10</span>, <span style="color:#89dceb">t6:</span><span style="color:#fab387">1</span></span></span></code></pre></div>
<p><code>rotl</code> on line 3 is the rotate left operation. It rotates its first operand (<code>t2</code>) by the number of bits specified in the second operand (i.e. 3).</p>
<p>After legalizing operations, we have the following DAG:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-llvm" data-lang="llvm"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span>  <span style="color:#89dceb">t0:</span> <span style="color:#f38ba8">ch</span>,<span style="color:#f38ba8">glue</span> = <span style="color:#f38ba8">EntryToken</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>  <span style="color:#89dceb">t2:</span> <span style="color:#cba6f7">i32</span>,<span style="color:#f38ba8">ch</span> = <span style="color:#f38ba8">CopyFromReg</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">0</span>, <span style="color:#89dceb">Register:</span><span style="color:#cba6f7">i32</span> %0
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>      <span style="color:#89dceb">t11:</span> <span style="color:#cba6f7">i32</span> = <span style="color:#cba6f7">shl</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">2</span>, <span style="color:#89dceb">Constant:</span><span style="color:#cba6f7">i32</span>&lt;<span style="color:#fab387">3</span>&gt;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">4</span><span>      <span style="color:#89dceb">t13:</span> <span style="color:#cba6f7">i32</span> = <span style="color:#f38ba8">srl</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">2</span>, <span style="color:#89dceb">Constant:</span><span style="color:#cba6f7">i32</span>&lt;<span style="color:#fab387">29</span>&gt;
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">5</span><span>    <span style="color:#89dceb">t14:</span> <span style="color:#cba6f7">i32</span> = <span style="color:#cba6f7">or</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">11</span>, <span style="color:#f38ba8">t</span><span style="color:#fab387">13</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">6</span><span>  <span style="color:#89dceb">t6:</span> <span style="color:#f38ba8">ch</span>,<span style="color:#f38ba8">glue</span> = <span style="color:#f38ba8">CopyToReg</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">0</span>, <span style="color:#89dceb">Register:</span><span style="color:#cba6f7">i32</span> <span style="color:#f38ba8">$x</span><span style="color:#fab387">10</span>, <span style="color:#f38ba8">t</span><span style="color:#fab387">14</span>
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">7</span><span>  <span style="color:#89dceb">t7:</span> <span style="color:#f38ba8">ch</span> = <span style="color:#89dceb">RISCVISD:</span><span style="color:#f38ba8">:RET_GLUE</span> <span style="color:#f38ba8">t</span><span style="color:#fab387">6</span>, <span style="color:#89dceb">Register:</span><span style="color:#cba6f7">i32</span> <span style="color:#f38ba8">$x</span><span style="color:#fab387">10</span>, <span style="color:#89dceb">t6:</span><span style="color:#fab387">1</span></span></span></code></pre></div>
<p>Line 3 to 5 in the post-legalized DAG show that we legalize <code>rotl</code> by <em>synthesizing</em> it with bitwise OR on the extractions of higher-bit part (i.e. <code>t11: i32 = shl t2, Constant:i32&lt;3&gt;</code>) and lower-bit part (i.e. <code>t13: i32 = srl t2, Constant:i32&lt;29&gt;</code>).</p>
<p>Of course, there are more than one way to legalize an operation. For instance, on embedded devices that don&rsquo;t have multiplication instructions, we might legalize a <code>mul</code> by simply replacing it with a call to library functions that &ldquo;emulate&rdquo; multiplications with a sequence of additions.</p>
<p>This brings us to the next section, where we ask a similar question we had seen before: how is an operation considered legal or illegal in a specific target? How do we handle illegal operations?</p>
<h4 id="determine-legal-operations-and-actions-on-illegal-operations">Determine legal operations and actions on illegal operations</h4>
<p>Contrary to what we&rsquo;ve seen in type legalizer, each target has to declare its own illegal operations and specify the desired way to handle each of them. This information is also placed in each target&rsquo;s TargetLowering (put under <code>XXXXISelLowering.cpp</code>). For example, RISC-V uses the following lines from <a href="https://github.com/llvm/llvm-project/blob/b7ed097f29d712b1cc839e15ab68d2c8a2ce07cc/llvm/lib/Target/RISCV/RISCVISelLowering.cpp#L353">here</a> (abridged for clarity) to declare rotations being illegal in the absent of Zbb / Zbkb extensions, and how to handle it:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#cba6f7">if</span> (<span style="color:#89dceb;font-weight:bold">!</span>Subtarget.<span style="color:#89b4fa">hasStdExtZbb</span>() <span style="color:#89dceb;font-weight:bold">&amp;&amp;</span> <span style="color:#89dceb;font-weight:bold">!</span>Subtarget.<span style="color:#89b4fa">hasStdExtZbkb</span>())
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>  <span style="color:#89b4fa">setOperationAction</span>({ISD<span style="color:#89dceb;font-weight:bold">::</span>ROTL, ISD<span style="color:#89dceb;font-weight:bold">::</span>ROTR}, XLenVT, Expand);</span></span></code></pre></div>
<p><code>setOperationAction</code> is the key here: for each opcode specified in its first argument (<code>ISD::ROTL</code> and <code>ISD::ROTR</code> in this case) that operates on value type specified by its second argument (i.e. <code>XLenVT</code>), we perform an action on the third argument (<code>Expand</code> in this case) to legalize it.</p>
<p>Let&rsquo;s look at the third argument first, here are the possible actions we can do to legalize an operation:</p>
<ul>
<li>Expand</li>
<li>LibCall</li>
<li>Promote</li>
<li>Custom</li>
</ul>
<p><strong>Expand</strong> tries to synthesize an operation with other legal operations, which we had seen how it worked on rotate left. The &ldquo;recipe&rdquo; to expand an operation is pre-defined (rather than defined by each target). If you&rsquo;re interested in learning what these recipes look like, most of them are put under <code>llvm/lib/CodeGen/SelectionDAG/TargetLowering.cpp</code> and <code>llvm/lib/CodeGen/SelectionDAG/LegalizeDAG.cpp</code>.</p>
<p>If the legalizer fails to expand an operation (e.g. none of the sub-operations used in synthesis are legal), it will fallback to the next action, <strong>LibCall</strong>, which replaces the operation with calls to library functions. Of course, a target can just set an operation&rsquo;s legalizer action directly to this. For instance, RISC-V <a href="https://github.com/llvm/llvm-project/blob/b7ed097f29d712b1cc839e15ab68d2c8a2ce07cc/llvm/lib/Target/RISCV/RISCVISelLowering.cpp#L1409">always uses</a> lock-free atomic builtin functions when the <code>forced-atomic</code> feature is enabled.</p>
<p><strong>Promote</strong> will promote an operation to operate on the next larger legal type. For instance, in a target where 32-bit and 64-bit integers are the legal types, <code>t3:i32 = add t2, Constant:i32&lt;5&gt;</code> will be promoted to <code>t3:i64 = add t2, Constant:i64&lt;5&gt;</code>. The recipes of how to promote individual operations are pre-defined, too. In fact, they are the same routines that are also used by the type legalizer.
Now, since we mentioned type legalizer, you may wonder: didn&rsquo;t we finish type legalization already? Why do we need to deal with type legality again?</p>
<p>Recall our takeaway at the end of last section: type legalization only cares about &ldquo;globally illegal&rdquo; types. That are, types which can&rsquo;t natively fit into any of the physical registers. It turns arbitrary types that can be as crazy as <code>i17</code> or <code>i87</code> into a small subset of legal types and it does this in an operation-agnostic fashion.
But within this small subset of legal types, some operations might only capable of handling an even <em>smaller</em> number of (legal) types!</p>
<p>An interesting example in RISC-V is the <em>Zfhmin</em> extension. Zfhmin is designed for a special scenarios where floating point values are stored in 16-bit format (i.e. F16), but majority of the arithmetics still operates on normal 32-bit floating points (i.e. F32). Therefore, in Zfhmin only data conversion / type casting operations like <code>fcvt.s.h</code> (convert from F16 to F32) support F16 while rest of the floating point operations are same as the F extension, which operate on F32. To deal with this type mixing, RISC-V backend declares F16 as legal type when Zfhmin is present, but mandates that all non-conversion F16 arithmetic instructions have to be promoted to F32 in this scenario:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#cba6f7">static</span> <span style="color:#cba6f7">const</span> <span style="color:#f38ba8">unsigned</span> ZfhminZfbfminPromoteOps[] <span style="color:#89dceb;font-weight:bold">=</span> {
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>    ISD<span style="color:#89dceb;font-weight:bold">::</span>FMINNUM,      ISD<span style="color:#89dceb;font-weight:bold">::</span>FMAXNUM,       ISD<span style="color:#89dceb;font-weight:bold">::</span>FADD,
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>    ISD<span style="color:#89dceb;font-weight:bold">::</span>FSUB,         ISD<span style="color:#89dceb;font-weight:bold">::</span>FMUL,          ISD<span style="color:#89dceb;font-weight:bold">::</span>FMA,
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">4</span><span>    ISD<span style="color:#89dceb;font-weight:bold">::</span>FDIV,         ISD<span style="color:#89dceb;font-weight:bold">::</span>FSQRT,         ISD<span style="color:#89dceb;font-weight:bold">::</span>FABS,
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">5</span><span>    ISD<span style="color:#89dceb;font-weight:bold">::</span>FNEG,         ...};
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">6</span><span>...
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">7</span><span><span style="color:#cba6f7">if</span> (Subtarget.<span style="color:#89b4fa">hasStdExtZfhminOrZhinxmin</span>() <span style="color:#89dceb;font-weight:bold">&amp;&amp;</span> <span style="color:#89dceb;font-weight:bold">!</span>Subtarget.<span style="color:#89b4fa">hasStdExtZfhOrZhinx</span>())
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">8</span><span>  <span style="color:#89b4fa">setOperationAction</span>(ZfhminZfbfminPromoteOps, MVT<span style="color:#89dceb;font-weight:bold">::</span>f16, Promote);</span></span></code></pre></div>
<p>(The above snippet is adapted from <a href="https://github.com/llvm/llvm-project/blob/b7ed097f29d712b1cc839e15ab68d2c8a2ce07cc/llvm/lib/Target/RISCV/RISCVISelLowering.cpp#L457">here</a>)</p>
<p>Now, onto the last legalization action: <strong>Custom</strong>.
As the name suggested, this is basically a wildcard action that allows a target to do whatever it wants on a generic SDNode. For each operation assigned to this action, <code>XXXXTargetLowering::LowerOperation</code> implements the actual legalization.</p>
<p>Take <code>ISD::FMINIMUM</code> and <code>ISD::FMAXIMUM</code> as an example, these two are floating point min/max operations conforming to IEEE-754-<strong>2019</strong> standard. The F extension in RISC-V, however, mostly<sup id="fnref:7"><a href="#fn:7" class="footnote-ref" role="doc-noteref">7</a></sup> conforms to IEEE-754-<strong>2008</strong> standard. Biggest difference between these two? Only IEEE-754-2019 propagates the NaN (Not-A-Number): If <em>either</em> A or B is a NaN, <code>fmaximum(A, B)</code> in IEEE-754-2019 returns a NaN; RISC-V&rsquo;s <code>fmaximum(A, B)</code>, on the other hand, returns NaN only if <em>both</em> A and B are NaNs.</p>
<p>So for RISC-V, doing custom legalization on <code>ISD::FMINIMUM</code> and <code>ISD::FMAXIMUM</code> would be an easier option to overcome this semantic mismatch.</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#cba6f7">if</span> (Subtarget.<span style="color:#89b4fa">hasStdExtFOrZfinx</span>() <span style="color:#89dceb;font-weight:bold">&amp;&amp;</span> <span style="color:#89dceb;font-weight:bold">!</span>Subtarget.<span style="color:#89b4fa">hasStdExtZfa</span>())
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>  <span style="color:#89b4fa">setOperationAction</span>({ISD<span style="color:#89dceb;font-weight:bold">::</span>FMAXIMUM, ISD<span style="color:#89dceb;font-weight:bold">::</span>FMINIMUM}, MVT<span style="color:#89dceb;font-weight:bold">::</span>f32, Custom);</span></span></code></pre></div>
<p>Then, in <code>lowerFMAXIMUM_FMINIMUM</code>, the <a href="https://github.com/llvm/llvm-project/blob/b7ed097f29d712b1cc839e15ab68d2c8a2ce07cc/llvm/lib/Target/RISCV/RISCVISelLowering.cpp#L5725">function</a> <code>RISCVTargetLowering::LowerOperation</code> calls to legalize those two operations, RISC-V adds an additional check that conditionally returns the result from its native fminimum/fmaximum instructions only when <em>neither</em> of the operands is NaN; otherwise, it returns a NaN.</p>
<p>Another thing worth noting is that, if a custom legalize action failed (e.g. the custom handler doesn&rsquo;t recognize/support the code it&rsquo;s looking at), it falls back to <em>Expand</em>. So the complete &ldquo;chain of legalizer fallbacks&rdquo; would be: Custom -&gt; Expand -&gt; LibCall.</p>
<h4 id="the-value-type-to-legalize">The value type to legalize</h4>
<p>Before wrapping up this section, I would like to spend some time on the second argument of <code>setOperationAction</code>: value type of the operation it&rsquo;s trying to legalize.
Theoretically, it represent the subset of legal types &ndash; given the fact that we have finished type legalization at this stage &ndash; that are not supported in a specific operation and demanded further legalizations.</p>
<p>As it turns out, <em>illegal</em> types can also be used on this argument!</p>
<p>For instance, in RV64 where 32-bit integer is considered an illegal type<sup id="fnref:8"><a href="#fn:8" class="footnote-ref" role="doc-noteref">8</a></sup>, we have the following line (abridged for clarity) for even the most basic operations like <code>ISD::ADD</code>:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#cba6f7">if</span> (Subtarget.<span style="color:#89b4fa">is64Bit</span>())
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>  <span style="color:#89b4fa">setOperationAction</span>({ISD<span style="color:#89dceb;font-weight:bold">::</span>ADD, ISD<span style="color:#89dceb;font-weight:bold">::</span>SUB, ISD<span style="color:#89dceb;font-weight:bold">::</span>SHL, ISD<span style="color:#89dceb;font-weight:bold">::</span>SRA, ISD<span style="color:#89dceb;font-weight:bold">::</span>SRL},
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>                      MVT<span style="color:#89dceb;font-weight:bold">::</span>i32, Custom);</span></span></code></pre></div>
<p>The truth is that, the relationship between type and operation legalizer is more&hellip;interwinded than we thought. Type legalizer mostly runs in an operation-agnostic fashion, but when it sees an illegal type, it actually asks the operation legalizer if there is a <code>Custom</code> action handler attached on this operation with the said illegal type, and tries to run that custom (operation) legalization preemptively.</p>
<p>The idea is that we want to have a leeway to legalize an operation with its <em>original</em> value type. Because unlike LLVM IR where we have explicit <code>zext</code>, <code>sext</code>, or <code>trunc</code> instructions to specify type conversions, in SelectionDAG all these extensions / truncations might be lowered into operations like <code>and t2, &lt;bit mask&gt;</code> (for zero extension) anytime before we actually legalize the operation, which increases the difficulties to recover those information.
Therefore, <code>Custom</code> legalizer action is allowed to handle illegal types.</p>
<p>Back to our RV64 example, the reason it wants custom legalization on <code>i32</code> is due to RV64&rsquo;s unique <em>widening</em> instructions, like <code>ADDW</code>, which takes two 32-bit integers and sign-extends them into 64-bit integers before the actual (64-bit) arithmetic addition. By replacing the original operations with these widening instructions preemptively in the <a href="https://github.com/llvm/llvm-project/blob/b7ed097f29d712b1cc839e15ab68d2c8a2ce07cc/llvm/lib/Target/RISCV/RISCVISelLowering.cpp#L11971">custom handler</a>, we could avoid extra sign-extension instructions that would have been created (by type legalizer) for each of its operands otherwise.</p>
<p>Since we have brought up <code>ADDW</code>, an instruction with 32-bit operands and 64-bit result, another interesting question related to <code>setOperationAction</code>&rsquo;s second argument is: <em>whose</em> type does this argument refer to? result type(s)? operand types? <em>which</em> operand&rsquo;s type?</p>
<p>For most of the instructions in majority of architectures, this is barely a question, since operands and results in simple arithmetics like ADD, SUB, and MUL usually have the same data type. But as we&rsquo;ve seen in <code>ADDW</code>&rsquo;s example, that&rsquo;s not always the case. Even worse, many operations don&rsquo;t even have a uniform data type for all their operands!</p>
<p>Take <strong>vector reduction</strong> as an example, it is a common vector operation that aggregates vector elements by a specific action (e.g. add, mul, and). For instance, the <code>llvm.vector.reduce.add</code> <a href="https://llvm.org/docs/LangRef.html#llvm-vector-reduce-add-intrinsic">intrinsic</a> produces an integer result that is the <em>summation</em> of all its elements. Some of its variant, <code>llvm.vector.reduce.fadd</code> which performs floating point add reduction, <a href="https://llvm.org/docs/LangRef.html#llvm-vector-reduce-fadd-intrinsic">has</a> a <em>scalar</em> start value as its first operand and the vector to sum up as the second operand.</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-llvm" data-lang="llvm"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#cba6f7">declare</span> <span style="color:#f38ba8">float</span> <span style="color:#f5e0dc">@llvm.vector.reduce.fadd.v4f32</span>(<span style="color:#f38ba8">float</span> <span style="color:#f5e0dc">%start_value</span>, &lt;<span style="color:#fab387">4</span> <span style="color:#cba6f7">x</span> <span style="color:#f38ba8">float</span>&gt; <span style="color:#f5e0dc">%v</span>)</span></span></code></pre></div>
<p>In this case, which type should we specify in <code>setOperationAction</code> for <code>ISD::VECREDUCE_FADD</code> (the opcode of <code>llvm.vector.reduce.fadd</code>)?</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#89b4fa">setOperationAction</span>(ISD<span style="color:#89dceb;font-weight:bold">::</span>VECREDUCE_FADD, <span style="color:#89dceb;font-weight:bold">???</span>, Custom);</span></span></code></pre></div>
<p>The answer for this particular question is the scalar operand&rsquo;s type (i.e. <code>float</code>). But can we use the vector operand&rsquo;s type instead to determine the legality of this operation?</p>
<p>Unfortunately, no.</p>
<p>The legalizer has already set the rule on which operand type or result type to use. This might not be a huge inconvenient in most cases, yet it still causes confusions and ambiguities sometimes, largely because these rules are not written in any documentations! (or any TableGen or .inc / .def files for easier lookups<sup id="fnref:9"><a href="#fn:9" class="footnote-ref" role="doc-noteref">9</a></sup>) They only appear in legalizer&rsquo;s codebase, specifically in the <code>SelectionDAGLegalize::LegalizeOp</code> function for most rules.</p>
<p>In addition to this issue, so far we&rsquo;ve seen several shortcomings on how legalization is designed in SelectionDAG ISel. In the last section of this post, I&rsquo;m going to briefly show you how another instruction selection framework in LLVM, <strong>GlobalISel</strong>, addresses some of these problems.</p>
<h3 id="legalization-in-globalisel-a-comparison">Legalization in GlobalISel: a comparison</h3>
<p>GlobalISel is a relatively new instruction selection framework designed to improve compilation time while producing code with a decent quality. It deserves its own blog posts (or even series!) so we&rsquo;re not going into the details here, but covering only its legalization component.</p>
<p>But even before switching the topic to GlobalISel, let&rsquo;s jump back to SelectionDAG ISel and take a moment to think about its overall flow:</p>
<ol>
<li>At the beginning, values from LLVM IR can have arbitrary types so crazy types like <code>i17</code> and <code>i87</code> might sprinkle here and there.</li>
<li>Type legalizer goes all the way to turn <em>every</em> of these illegal types into a small set of legal types.</li>
<li>But then, you found out: &ldquo;Oops, each operation might have their own preference on the types it supports&rdquo;. Namely, these types are what an operation <em>actually</em> wants.</li>
<li>We legalizes individual operations to iron out those unsupported <strong>legal</strong> types as well as unsupported operations.</li>
<li>But if our focus has always been the types supported by individual operations&hellip;</li>
</ol>
<p><em>Then why can&rsquo;t we just jump from Step (1) to Step (4)?</em></p>
<p>Why can&rsquo;t we <strong>consolidate</strong> type and operation legalization into a single stage?</p>
<p>And that is basically what GlobalISel does: for each operation, we specify its legal types and the &ldquo;recipes&rdquo; for legalizing it <em>at the same place</em>.
The interface to describe these information has a similar look to the <code>setOperationAction</code> function we&rsquo;ve seen previously in SelectionDAG ISel. Let&rsquo;s see an example from RISC-V&rsquo;s GlobalISel legalizer:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#89b4fa">getActionDefinitionsBuilder</span>({G_ADD, G_SUB, G_AND, G_OR, G_XOR})
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>    .<span style="color:#89b4fa">legalFor</span>({s32, sXLen})
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>    .<span style="color:#89b4fa">legalIf</span>(<span style="color:#89b4fa">typeIsLegalIntOrFPVec</span>(<span style="color:#fab387">0</span>, IntOrFPVecTys, ST))
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">4</span><span>    .<span style="color:#89b4fa">widenScalarToNextPow2</span>(<span style="color:#fab387">0</span>)
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">5</span><span>    .<span style="color:#89b4fa">clampScalar</span>(<span style="color:#fab387">0</span>, s32, sXLen);</span></span></code></pre></div>
<p><code>getActionDefinitionsBuilder</code> here specifies the legality of operations listed in its first argument: <code>G_ADD</code>, <code>G_SUB</code>, <code>G_AND</code> etc. They are opcodes for (generic) operations in GlobalISel, similar to <code>ISD::ADD</code>, <code>ISD::SUB</code>, and <code>ISD::AND</code> in SelectionDAG ISel.</p>
<p>The next line describes the legal types of its operands. More specifically, <code>legalFor({s32, sXLen})</code> says that operand 0 is considered legal if it&rsquo;s a 32-bit scalar or a <code>XLen</code> type. Note that the first operand of an operation in GlobalISel, called a <a href="https://llvm.org/docs/GlobalISel/GMIR.html">generic Machine IR (gMIR)</a> instruction, actually represents the instruction&rsquo;s <strong>result</strong>. So we&rsquo;re specifying the legal result type here; the line after is doing a similar thing, but calling out to another predicate function <code>typeIsLegalIntOrFPVec</code> to determine the legality.</p>
<p>After declaring the legal types, it&rsquo;s time to describe how to deal with the <em>illegal</em> ones (e.g. crazy types like <code>i17</code> and <code>i87</code>). If we look at the lines follows, <code>widenScalarToNextPow2(0)</code> will make illegal types at operand 0 widen to the next type with power-of-two size, before the resulting types being clamped by <code>clampScalar</code> into a type range bounded by 32-bit scalar and <code>XLen</code>.</p>
<p>The aforementioned function calls compose a chain of legalization steps consisting of <em>checks</em> (e.g. <code>legalFor</code>) and <em>actions</em> (e.g. <code>clampScalar</code>) that are executed in sequence. There are also some familiar actions that we&rsquo;ve seen earlier, for example:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#89b4fa">getActionDefinitionsBuilder</span>(G_SEXT_INREG)
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>    .<span style="color:#89b4fa">customFor</span>({sXLen})
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>    .<span style="color:#89b4fa">maxScalar</span>(<span style="color:#fab387">0</span>, sXLen)
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">4</span><span>    .<span style="color:#89b4fa">lower</span>();</span></span></code></pre></div>
<p><code>customFor</code> has the same effect as the <code>Custom</code> action we&rsquo;ve seen in <code>setOperationAction</code>: delegating the legalization to custom handlers reside in each target&rsquo;s <code>LegalizerInfo::legalizeCustom</code>. If this step fails, it falls to the next action, <code>maxScalar</code>, which sets an upper bound on the type size and goes to the final action, <code>lower</code>, which is basically the <code>Expand</code> action in SelectionDAG&rsquo;s legalizer.</p>
<p>In the previous section, we mentioned that SelectionDAG legalizer uses one of the operand types to check against the second argument of <code>setOperationAction</code> for determining the operation&rsquo;s legality. As of which operand types to pick, it&rsquo;s predefined and sometimes causing some confusions and ambiguities.</p>
<p>GlobalISel&rsquo;s legalizer, on the other hand, has more flexibility on which operand you want to legalize. We&rsquo;ve already got a hint from our previous examples, where we can designate a specific operand index subject to the legalizer action. So for instructions without a uniform operand types, like interger-to-pointer, it becomes easy to specify the action for its integer operand only:</p>






<div class="highlight"><pre tabindex="0" style="color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">1</span><span><span style="color:#89b4fa">getActionDefinitionsBuilder</span>(G_INTTOPTR)
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">2</span><span>    .<span style="color:#89b4fa">legalFor</span>({{p0, sXLen}})
</span></span><span style="display:flex;"><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f849c">3</span><span>    .<span style="color:#89b4fa">clampScalar</span>(<span style="color:#fab387">1</span>, sXLen, sXLen);</span></span></code></pre></div>
<p>To summarize, GlobalISel&rsquo;s legalizer expresses legalities &ndash; especially type legalities &ndash; in a more <em>explicit</em> way. Consolidating all legalizations into one phase also helps people to understand them better.</p>
<h3 id="epilogue">Epilogue</h3>
<p>Without a doubt, we need to create more learning resources for LLVM backend development. This post is my humble effort to shed some lights on a really important backend subsystem, which we&rsquo;re not even able to get to instruction selection without it. I hope you learn how SelectionDAG ISel&rsquo;s type and operation legalizer interacts with each other and how to specify the action to legalize illegal types or operations. I also hope you enjoy the last section on a more modern legalizer design.</p>
<p>Thanks for reading!</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>Status registers like EFLAGS in X86 might qualify (I mean its individual status bits), but it&rsquo;s still far away from being generally usable.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>Though frontends like Clang do generate target-specific LLVM IR, a lot of those target-specific bits are in regard to ABI conformance rather than legalizations.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>At the time of writing, the codegen pipeline hasn&rsquo;t migrated to using the <em>new</em> PassManager yet, while the middle-end had wrapped up the migration years ago.&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p>Floating point is optional in RISC-V, and we&rsquo;re not covering it here either.&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5">
<p>Well, not always a single SDNode, since the SelectionDAG builder actually delegates lots of DAG building logics to each target and each target can definitely generate more than one SDNode from a LLVM instruction. The most notable example is function calls: each target implements <code>TargetLowering::LowerCall</code> to lower a <code>llvm::CallInst</code> to its native function call constructions consisting of one or more SDNodes.&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6">
<p>The full list of opcodes can be found under <a href="https://github.com/llvm/llvm-project/blob/main/llvm/include/llvm/CodeGen/ISDOpcodes.h">llvm/include/llvm/CodeGen/ISDOpcodes.h</a>.&#160;<a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:7">
<p>Except the fact that RISC-V&rsquo;s F extension does make -0.0 smaller than +0.0, which is a IEEE-754-2019 feature.&#160;<a href="#fnref:7" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:8">
<p>Unless you flip an experimental flag <code>-riscv-experimental-rv64-legal-i32</code> to say otherwise.&#160;<a href="#fnref:8" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:9">
<p>One exception might be VP (Vector Predicated) intrinsics, whose operand for legalization can be found in <code>llvm/include/llvm/IR/VPIntrinsics.def</code>.&#160;<a href="#fnref:9" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded></item><item><title>Publications</title><link>https://myhsu.xyz/publications/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>min@myhsu.dev (Min-Yih Hsu)</author><guid>https://myhsu.xyz/publications/</guid><description>Book Min-Yih Hsu. “LLVM Techniques, Tips, and Best Practices Clang and Middle-End Libraries: Design Powerful and Reliable Compilers Using the Latest Libraries and Tools from LLVM”. Packt Publishing (2021). Amazon Link.
Paper and Talk Min-Yih Hsu, Felicitas Hetzelt, David Gens, Michael Maitland, and Michael Franz. &amp;ldquo;A Highly Scalable, Hybrid, Cross-Platform Timing Analysis Framework Providing Accurate Differential Throughput Estimation via Instruction-Level Tracing&amp;rdquo; In Proceedings of ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering (ESEC/FSE) 2023.</description><content:encoded><![CDATA[<h3 id="book">Book</h3>
<p><u>Min-Yih Hsu</u>. “LLVM Techniques, Tips, and Best Practices Clang and Middle-End Libraries: Design Powerful and Reliable Compilers Using the Latest Libraries and Tools from LLVM”. <em>Packt Publishing</em> (2021). <a href="https://a.co/d/0AXkEdI">Amazon Link</a>.</p>
<h3 id="paper-and-talk">Paper and Talk</h3>
<ul>
<li><u>Min-Yih Hsu</u>, Felicitas Hetzelt, David Gens, Michael Maitland, and Michael Franz. &ldquo;A Highly Scalable, Hybrid, Cross-Platform Timing Analysis Framework Providing Accurate Differential Throughput Estimation via Instruction-Level Tracing&rdquo; In <em>Proceedings of ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering (ESEC/FSE)</em> 2023. <a href="https://doi.org/10.1145/3611643.3616246">https://doi.org/10.1145/3611643.3616246</a></li>
<li><u>Min-Yih Hsu</u>, David Gens, Michael Franz. “MCA Daemon: Hybrid Throughput Analysis Beyond Basic Blocks”. <em>EuroLLVM Developers Meeting</em> (2022). <a href="https://youtu.be/ZGEP7JEIKNo">[Recording]</a><a href="https://llvm.org/devmtg/2022-05/slides/2022EuroLLVM-MCA-Deamon.pdf">[Slides]</a></li>
<li><u>Min-Yih Hsu</u>, Stan Kvasov, and Vince Del Vecchio. “Souper-Charging Peepholes with Target Machine Info”. <em>LLVM Developers Meeting</em> (2019). <a href="https://youtu.be/5eSOWM0upN8">[Recording]</a><a href="https://llvm.org/devmtg/2019-10/slides/Hsu-Souper-ChargingPeepholes.pdf">[Slides]</a></li>
<li>Chun-Chieh Yang, Shao-Chung Wang, <u>Min-Yih Hsu</u>, and Jenq-Kuen Lee et al. &ldquo;OpenCL 2.0 Compiler Adaptation on LLVM for PTX Simulators&rdquo;. <em>THE INTERNATIONAL WORKSHOP ON EMBEDDED MULTICORE SYSTEMS(ICPP-EMS)</em>(2017). <a href="https://doi.org/10.1109/ICPPW.2017.21">https://doi.org/10.1109/ICPPW.2017.21</a></li>
<li><u>Min-Yih Hsu</u>, and Jenq-Kuen Lee. &ldquo;Hydra LLVM: Instruction Selection with Threads.&rdquo; <em>European LLVM Developers Meeting</em> (2017).</li>
<li>Li Wang, Shao-Chung Wang, <u>Min-Yih Hsu</u>, and Jenq-Kuen Lee et al. &ldquo;Analyzing OpenCL 2.0 Workloads Using a Heterogeneous CPU-GPU Simulator.&rdquo; <em>IEEE International Symposium on Performance Analysis of Systems and Software</em> (2017). <a href="https://doi.org/10.1109/ISPASS.2017.7975279">https://doi.org/10.1109/ISPASS.2017.7975279</a></li>
</ul>
<h3 id="technical-writing">Technical Writing</h3>
<ul>
<li><a href="/blog">Just Read the Code</a></li>
<li><a href="https://m680x0.github.io/blog/">M68k LLVM Development Blog</a></li>
<li><a href="https://medium.com/@mshockwave">Medium</a> (Discontinued)</li>
<li><a href="http://mshockwave.blogspot.tw/">Showckwave Base</a> (Discontinued)</li>
</ul>
]]></content:encoded></item></channel></rss>