<!doctype html><html lang=en><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Scheduling Model in LLVM - Part II&nbsp;|&nbsp;Min Hsu's Homepage</title>
<meta name=title content="Scheduling Model in LLVM - Part II"><meta name=description content="In the previous post, we covered the basics of scheduling model in LLVM. Specifically, per-operand tokens that connect an instruction with models that spell out processor-specific scheduling properties like instruction latency, and the concept of processor resources with different sizes of buffer.
While I was planning to write how scheduling models are used in this post &ndash; namely, covering things like instruction scheduler and MCA &ndash; the draft was overwhelmed by the sheer amount of content needed to cover just the substrate."><meta name=keywords content="llvm,compiler-instruction-scheduling,"><meta name=author content="Min-Yih Hsu"><meta property="og:title" content="Scheduling Model in LLVM - Part II"><meta property="og:description" content="In the previous post, we covered the basics of scheduling model in LLVM. Specifically, per-operand tokens that connect an instruction with models that spell out processor-specific scheduling properties like instruction latency, and the concept of processor resources with different sizes of buffer.
While I was planning to write how scheduling models are used in this post &ndash; namely, covering things like instruction scheduler and MCA &ndash; the draft was overwhelmed by the sheer amount of content needed to cover just the substrate."><meta property="og:type" content="article"><meta property="og:url" content="https://myhsu.xyz/llvm-sched-model-1.5/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-10-28T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-28T00:00:00+00:00"><meta property="og:site_name" content="Min Hsu's Homepage"><meta name=twitter:card content="summary"><meta name=twitter:title content="Scheduling Model in LLVM - Part II"><meta name=twitter:description content="In the previous post, we covered the basics of scheduling model in LLVM. Specifically, per-operand tokens that connect an instruction with models that spell out processor-specific scheduling properties like instruction latency, and the concept of processor resources with different sizes of buffer.
While I was planning to write how scheduling models are used in this post &ndash; namely, covering things like instruction scheduler and MCA &ndash; the draft was overwhelmed by the sheer amount of content needed to cover just the substrate."><meta itemprop=name content="Scheduling Model in LLVM - Part II"><meta itemprop=description content="In the previous post, we covered the basics of scheduling model in LLVM. Specifically, per-operand tokens that connect an instruction with models that spell out processor-specific scheduling properties like instruction latency, and the concept of processor resources with different sizes of buffer.
While I was planning to write how scheduling models are used in this post &ndash; namely, covering things like instruction scheduler and MCA &ndash; the draft was overwhelmed by the sheer amount of content needed to cover just the substrate."><meta itemprop=datePublished content="2024-10-28T00:00:00+00:00"><meta itemprop=dateModified content="2024-10-28T00:00:00+00:00"><meta itemprop=wordCount content="3349"><meta itemprop=keywords content="llvm,compiler-instruction-scheduling,"><meta name=referrer content="no-referrer-when-downgrade"><link href=/simple.min.css rel=stylesheet><link href=/style.min.css rel=stylesheet></head><body><header><nav><a href=/>Home</a>
<a href=/publications/>Publications</a>
<a href=/blog/>Blog</a>
<a href=https://github.com/mshockwave>GitHub</a>
<a href=https://www.linkedin.com/in/bekketmcclane/>LinkedIn</a>
<a href=/index.xml><svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 448 512"><path d="M0 64C0 46.3 14.3 32 32 32c229.8.0 416 186.2 416 416 0 17.7-14.3 32-32 32s-32-14.3-32-32C384 253.6 226.4 96 32 96 14.3 96 0 81.7.0 64zM0 416a64 64 0 11128 0A64 64 0 110 416zM32 160c159.1.0 288 128.9 288 288 0 17.7-14.3 32-32 32s-32-14.3-32-32c0-123.7-100.3-224-224-224-17.7.0-32-14.3-32-32s14.3-32 32-32z"/></svg>
RSS</a></nav><h1>Scheduling Model in LLVM - Part II</h1></header><main><p><i><time datetime=2024-10-28 pubdate>2024-10-28</time></i></p><content><p>In the <a href=/llvm-sched-model-1>previous post</a>, we covered the basics of scheduling model in LLVM. Specifically, per-operand tokens that connect an instruction with models that spell out processor-specific scheduling properties like instruction latency, and the concept of processor resources with different sizes of buffer.</p><p>While I <em>was</em> planning to write how scheduling models are used in this post &ndash; namely, covering things like instruction scheduler and MCA &ndash; the draft was overwhelmed by the sheer amount of content needed to cover just the substrate. In addition, I found that I missed some more advanced yet commonly used constructions in the previous post. So if you&rsquo;ll excuse me, I&rsquo;d like to procrastinate writing about MachineScheduler and MCA, leaving it for future Min to worry, and dive into three important scheduling model constructions in this post: number of <code>ProcResource</code> units, <code>ProcResGroup</code>, and super resource.</p><p>These three horsemen together enable scheduling models to express <strong>hierarchy</strong> structure &ndash; a concept that we have only scratched the surface previously. Modern microarchitectures often employ complicated processor resource distributions and groupings, like having multiple execution pipes with asymmetric capabilities. It is of paramount importance to express those structures with the things we&rsquo;re about to cover.
Without further ado, let&rsquo;s start with the number of <code>ProcResource</code> units!</p><h3 id=number-of-units-in-a-procresource>Number of units in a ProcResource</h3><p>So far we&rsquo;ve mentioned things like <code>ProcResource&lt;1></code> or <code>ProcResource&lt;2></code> several times without explaining the numbers in the template argument list. That specific argument stands for the <strong>number of units</strong> in a processor resource.</p><p>This property is directly related to the <em>throughput</em> of this resource, namely, how many uops can it process in a given time. To give you a more concrete example, let&rsquo;s see how LLVM&rsquo;s scheduling model calculates the <strong>reciprocal throughput</strong> &ndash; a synonym of <em>inverse</em> throughput &ndash; of an instruction.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 1</span><span>std<span style=color:#89dceb;font-weight:700>::</span>optional<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#f38ba8>double</span><span style=color:#89dceb;font-weight:700>&gt;</span> Throughput;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 2</span><span><span style=color:#cba6f7>const</span> MCSchedModel <span style=color:#89dceb;font-weight:700>&amp;</span>SM <span style=color:#89dceb;font-weight:700>=</span> STI.getSchedModel();
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 3</span><span><span style=color:#cba6f7>const</span> MCWriteProcResEntry <span style=color:#89dceb;font-weight:700>*</span>I <span style=color:#89dceb;font-weight:700>=</span> STI.getWriteProcResBegin(<span style=color:#89dceb;font-weight:700>&amp;</span>SCDesc);
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 4</span><span><span style=color:#cba6f7>const</span> MCWriteProcResEntry <span style=color:#89dceb;font-weight:700>*</span>E <span style=color:#89dceb;font-weight:700>=</span> STI.getWriteProcResEnd(<span style=color:#89dceb;font-weight:700>&amp;</span>SCDesc);
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 5</span><span><span style=color:#cba6f7>for</span> (; I <span style=color:#89dceb;font-weight:700>!=</span> E; <span style=color:#89dceb;font-weight:700>++</span>I) {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 6</span><span>  <span style=color:#cba6f7>if</span> (<span style=color:#89dceb;font-weight:700>!</span>I<span style=color:#89dceb;font-weight:700>-&gt;</span>ReleaseAtCycle)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 7</span><span>    <span style=color:#cba6f7>continue</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 8</span><span>  <span style=color:#f38ba8>unsigned</span> NumUnits <span style=color:#89dceb;font-weight:700>=</span> SM.getProcResource(I<span style=color:#89dceb;font-weight:700>-&gt;</span>ProcResourceIdx)<span style=color:#89dceb;font-weight:700>-&gt;</span>NumUnits;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 9</span><span>  <span style=color:#f38ba8>double</span> Temp <span style=color:#89dceb;font-weight:700>=</span> NumUnits <span style=color:#89dceb;font-weight:700>*</span> <span style=color:#fab387>1.0</span> <span style=color:#89dceb;font-weight:700>/</span> I<span style=color:#89dceb;font-weight:700>-&gt;</span>ReleaseAtCycle;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">10</span><span>  Throughput <span style=color:#89dceb;font-weight:700>=</span> Throughput <span style=color:#89dceb;font-weight:700>?</span> std<span style=color:#89dceb;font-weight:700>::</span>min(<span style=color:#89dceb;font-weight:700>*</span>Throughput, Temp) <span style=color:#89dceb;font-weight:700>:</span> Temp;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">11</span><span>}
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">12</span><span><span style=color:#cba6f7>if</span> (Throughput)
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">13</span><span>  <span style=color:#cba6f7>return</span> <span style=color:#fab387>1.0</span> <span style=color:#89dceb;font-weight:700>/</span> <span style=color:#89dceb;font-weight:700>*</span>Throughput;</span></span></code></pre></div><p>The code above is <a href=https://github.com/llvm/llvm-project/blob/c2717a89b8437d041d532c7b2c535ca4f4b35872/llvm/lib/MC/MCSchedule.cpp#L90>excerpted</a> from <code>MCSchedModel::getReciprocalThroughput</code>: it scans through every write resources in this instruction (represented by its scheduling class, <code>SCDesc</code>) via each resource&rsquo;s index <code>ProcResourceIdx</code>.
The throughput contributed by each resource used by this instruction is calculated by dividing the number of units (<code>NumUnits</code>) by <code>ReleaseAtCycle</code>, which is the number of cycles reserved on this resource. We eventually take the largest inverse throughput (i.e. smallest throughput) among all the resources as the overall throughput of this instruction.</p><p>A single <code>ProcResource</code> with number of unit larger than one is equivalent to multiple <em>identical</em> <code>ProcResource</code> instances. For example, let&rsquo;s say we have the following scheudling model:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">1</span><span>def <span style=color:#89dceb>IEX</span> : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>3</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">2</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">3</span><span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteIMul, [IEX]<span style=color:#89dceb;font-weight:700>&gt;</span>;</span></span></code></pre></div><p>In this model, we assign <code>IEX</code> (integer execution pipes) to <code>WriteIMul</code> &ndash; a SchedWrite token that represents integer multiplication instructions. This is equivalent to having three individual integer pipes &ndash; <code>IEX0</code>, <code>IEX1</code>, and <code>IEX2</code>, where <em>any</em> of them can do multiplications:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">1</span><span>def <span style=color:#89dceb>IEX0</span> : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>1</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">2</span><span>def <span style=color:#89dceb>IEX1</span> : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>1</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">3</span><span>def <span style=color:#89dceb>IEX2</span> : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>1</span><span style=color:#89dceb;font-weight:700>&gt;</span>;</span></span></code></pre></div><p>Having (effectively) three available pipes also means that we can dispatch three multiplications in parallel! Take the following RISC-V assembly snippet as an example, assuming we&rsquo;re dispatching them into this model with an issue width of 6. Since there is no Read-After-Write (RAW) dependencies among the instructions, we can dispatch them in parallel.</p><pre tabindex=0><code>mul a1, a1, a2
mul t4, t4, t5
mul r7, r7, r0</code></pre><p>What we&rsquo;re interested in here, is how each of them <strong>consumes</strong> processor resources. We can visualize this process with the following resource consumption table:</p><table><thead><tr><th style=text-align:center>instruction</th><th style=text-align:center>IEX0</th><th style=text-align:center>IEX1</th><th style=text-align:center>IEX2</th></tr></thead><tbody><tr><td style=text-align:center>mul a1, a1, a2</td><td style=text-align:center>Consumed</td><td style=text-align:center>Available</td><td style=text-align:center>Available</td></tr><tr><td style=text-align:center>mul t4, t4, t5</td><td style=text-align:center>Consumed</td><td style=text-align:center>Available</td><td style=text-align:center>Consumed</td></tr><tr><td style=text-align:center>mul t0, t0, t1</td><td style=text-align:center>Consumed</td><td style=text-align:center>Consumed</td><td style=text-align:center>Consumed</td></tr></tbody></table><p>The instructions are dispatched from top to bottom. For each of the instruction, we randomly<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> look for an empty pipe to dispatch it into.</p><p>Alternatiely, we can rewrite this table into a more compact format:</p><table><thead><tr><th style=text-align:center>instruction</th><th style=text-align:center>Consumed IEX units</th></tr></thead><tbody><tr><td style=text-align:center>mul a1, a1, a2</td><td style=text-align:center>1 / 3</td></tr><tr><td style=text-align:center>mul t4, t4, t5</td><td style=text-align:center>2 / 3</td></tr><tr><td style=text-align:center>mul t0, t0, t1</td><td style=text-align:center>3 / 3</td></tr></tbody></table><p>In this table, we focus on the <em>number</em> of consumed units in <code>def IEX : ProcResource&lt;3></code>, where <code>2 / 3</code> means &ldquo;two out of three total units are consumed&rdquo;. This table will come into handy later when we&rsquo;re discussing more advanced scheduling model concepts.</p><p>But for now, let&rsquo;s step back for a second: if dispatching to <code>ProcResource&lt;3></code> is equivalent to doing the same thing against three individual <code>ProcResource&lt;1></code> where we can dispatch an instruction to <em>any</em> of them&mldr;</p><p>Haven&rsquo;t we seen something similar in the previous post already?</p><p>That&rsquo;s right! It&rsquo;s <code>ProcResGroup</code>. This is what we have after rewriting the same model with <code>ProcResGroup</code>:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">1</span><span>def <span style=color:#89dceb>IEX0</span> : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>1</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">2</span><span>def <span style=color:#89dceb>IEX1</span> : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>1</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">3</span><span>def <span style=color:#89dceb>IEX2</span> : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>1</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">4</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">5</span><span>def <span style=color:#89dceb>IEX</span> : ProcResGroup<span style=color:#89dceb;font-weight:700>&lt;</span>[IEX0, IEX1, IEX2]<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">6</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">7</span><span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteIMul, [IEX]<span style=color:#89dceb;font-weight:700>&gt;</span>;</span></span></code></pre></div><p>Both models express the fact that multiplication instructions can run on any of the three integer pipes.</p><p>But then it prompts a question: if they&rsquo;re so similar, why do we have two different syntax in the first place?</p><p>The key, as it turns out, is the fact that we were dealing with three <strong>identical</strong> pipes in the previous example. In reality, we might not always have execution units with the same capabilities. For example, here is a more realistic design:</p><div style=text-align:center><picture><source srcset=/images/llvm-sched-model-hierarchy-example.dark.svg media="(prefers-color-scheme: dark)"><img src=/images/llvm-sched-model-hierarchy-example.light.svg></picture></div><p>In this design, only two out of three pipes are capable of doing multiplications; divisions and cryptographies, on the other hand, can only run on one of the pipes.</p><p>The rationale behind this design is that complex operations like division or cryptography usually take up a larger chip area and draw more power, while being less commonly used. So it&rsquo;s pretty common to have a heterogeneous layout where certain operations are only available in a subset of execution units.</p><p>With only a single <code>def IEX : ProcResource&lt;3></code>, it&rsquo;ll be more difficult to express the resources used by each kind of instructions because currently there is no way to say something like &ldquo;WriteIDiv uses the second unit of <code>IEX</code>&rdquo;:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 1</span><span>def <span style=color:#89dceb>IEX</span> : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>3</span><span style=color:#89dceb;font-weight:700>&gt;</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 2</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 3</span><span><span style=color:#6c7086;font-style:italic>// Simple arithmetics, like ADD
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 4</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteIALU,   [IEX]<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 5</span><span><span style=color:#6c7086;font-style:italic>// Multiplication
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 6</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteIMul,   [<span style=color:#6c7086;font-style:italic>/*IEX[0] and IEX[2]??*/</span>]<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 7</span><span><span style=color:#6c7086;font-style:italic>// Division
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 8</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteIDiv,   [<span style=color:#6c7086;font-style:italic>/*IEX[1]??*/</span>]<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 9</span><span><span style=color:#6c7086;font-style:italic>// Cryptography
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">10</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteCrypto, [<span style=color:#6c7086;font-style:italic>/*IEX[2]??*/</span>]<span style=color:#89dceb;font-weight:700>&gt;</span>;</span></span></code></pre></div><p>On the contrary, it&rsquo;s much more straight forward to express it with the <code>ProcResGroup</code> we had introduced in the <a href=/llvm-sched-model-1>previous post</a>:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 1</span><span>def <span style=color:#89dceb>IEX0</span> : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>1</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 2</span><span>def <span style=color:#89dceb>IEX1</span> : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>1</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 3</span><span>def <span style=color:#89dceb>IEX2</span> : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>1</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 4</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 5</span><span>def <span style=color:#89dceb>IntegerArith</span> : ProcResGroup<span style=color:#89dceb;font-weight:700>&lt;</span>[IEX0, IEX1, IEX2]<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 6</span><span>def <span style=color:#89dceb>IntegerMul</span>   : ProcResGroup<span style=color:#89dceb;font-weight:700>&lt;</span>[IEX0, IEX2]<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 7</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 8</span><span><span style=color:#6c7086;font-style:italic>// Simple arithmetics, like ADD
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 9</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteIALU,   [IntegerArith]<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">10</span><span><span style=color:#6c7086;font-style:italic>// Multiplication
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">11</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteIMul,   [IntegerMul]<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">12</span><span><span style=color:#6c7086;font-style:italic>// Division
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">13</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteIDiv,   [IEX1]<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">14</span><span><span style=color:#6c7086;font-style:italic>// Cryptography
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">15</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteCrypto, [IEX2]<span style=color:#89dceb;font-weight:700>&gt;</span>;</span></span></code></pre></div><p>As a quick recap: by consuming <code>ProcResGroup&lt;[IEX0, IEX2]></code>, a multiplication instruction might run on either <code>IEX0</code> or <code>IEX2</code> during runtime.</p><p>It is worth pointing out that with this model, we have to deal with resource consumptions that go across <em>different</em> <code>ProcResource</code> and <code>ProcResGroup</code>. For instance, when we dispatch a cryptography instruction, the instruction not only consumes <code>IEX2</code> but also effectively decreases the number of available units in <code>IntegerArith</code> <strong>and</strong> <code>IntegerMul</code> &ndash; which is what multiplication consumes &ndash; because <code>IEX2</code> presents in both <code>ProcResGroup</code>.</p><p>In order to account for <strong>overlapping</strong> <code>ProcResource</code> and <code>ProcResGroup</code>, for each <code>ProcResource</code> or <code>ProcResGroup</code> used by an instruction, LLVM actually inserts an <em>implicit</em> processor resource usage for every <code>ProcResGroup</code> it overlaps. Using the snippet above as an example, this is what it looks like after such &ldquo;expansion&rdquo;:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">1</span><span><span style=color:#6c7086;font-style:italic>// Simple arithmetics, like ADD
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">2</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteIALU,   [IntegerArith]<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">3</span><span><span style=color:#6c7086;font-style:italic>// Multiplication
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">4</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteIMul,   [IntegerMul, IntegerArith]<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">5</span><span><span style=color:#6c7086;font-style:italic>// Division
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">6</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteIDiv,   [IEX1, IntegerArith]<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">7</span><span><span style=color:#6c7086;font-style:italic>// Cryptography
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">8</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteCrypto, [IEX2, IntegerArith, IntegerMul]<span style=color:#89dceb;font-weight:700>&gt;</span>;</span></span></code></pre></div><p>A cryptography now consumes not only <code>IEX2</code>, but also one <code>IntegerArith</code> unit and one <code>IntegerMul</code> unit upon dispatch. So if we dispatch the following RISC-V instruction sequence<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>:</p><pre tabindex=0><code>mul        s0, s0, a2
sha256sum0 a0, a1
mul        a3, a3, t0</code></pre><p>Here is what happens at cycle 0:</p><table><thead><tr><th style=text-align:center>instruction</th><th style=text-align:center>IntegerArith</th><th style=text-align:center>IntegerMul</th><th style=text-align:center>IEX2</th></tr></thead><tbody><tr><td style=text-align:center>mul s0, s0, a2</td><td style=text-align:center>1 / 3</td><td style=text-align:center>1 / 2</td><td style=text-align:center>0 / 1</td></tr><tr><td style=text-align:center>sha256sum0 a0, a1</td><td style=text-align:center>2 / 3</td><td style=text-align:center>2 / 2</td><td style=text-align:center>1 / 1</td></tr><tr><td style=text-align:center>mul a3, a3, t0</td><td style=text-align:center>3 / 3</td><td style=text-align:center>FAIL TO CONSUME</td><td style=text-align:center>1 / 1</td></tr></tbody></table><p>The first multiplication instruction consumes both <code>IntegerArith</code> <em>and</em> <code>IntegerMul</code>. Because <code>IntegerArith</code> has overlapping resources with <code>IntegerMul</code> &ndash; <code>IEX0</code> and <code>IEX2</code>, to be precise.</p><p>Similarly, when it comes to the <code>sha256sum0</code> instruction, it increases the number of consumed resources on not just <code>IEX2</code> but <code>IntegerArith</code> and <code>IntegerMul</code> as well. Lastly, for the last multiplication instruction, its attempt to acquire <code>IntegerMul</code> will fail because we no longer have spare capacity in that resource, which causes the instruction to <strong>stall</strong> during the dispatch stage, namely, a <em>dispatch hazard</em>.</p><p><code>ProcResGroup</code> gives you the ability to reference a <em>subset</em> of execution units, which is suitable for modeling units with heterogeneous capabilities. And as it turns out, there is actually a second way to reference subsets of execution units &ndash; <strong>super resource</strong>.</p><h3 id=super-resource>Super resource</h3><p>Super resource allows us to construct a hierarchy between two <code>ProcResource</code> instances (NOT <code>ProcResGroup</code>). In this relationship, the child <code>ProcResource</code> represents a subset of units from the parent <code>ProcResource</code>.</p><p>To give you a better idea, let&rsquo;s see a real-world example from the <strong>Load / Store Unit (LSU)</strong> in AMD Zen3.</p><figure style=text-align:center><img src=/images/zen3-uarch-lsu.png><figcaption>Image source: <a href=https://chipsandcheese.com/2022/11/05/amds-zen-4-part-1-frontend-and-execution-engine/>Chips and Cheese</a>. Captured from the <a href=https://old.chipsandcheese.com/2022/11/05/amds-zen-4-part-1-frontend-and-execution-engine/zen3-drawio/>original image </a>.</figcaption></figure><p>The diagram above shows the LSU part of <a href=https://old.chipsandcheese.com/2022/11/05/amds-zen-4-part-1-frontend-and-execution-engine/zen3-drawio/>Zen3&rsquo;s microarchitecture</a>. There are three arrows between load & store queues and L1 Data Cache, along with an equal number of AGUs (Address Generation Unit) positioned above the queues.</p><p>You might notice that among all three arrows, which are load and store pipes, between the queues and L1 Data Cache, only two of them goes down (indicating <em>stores</em>) while there are three going up (indicating <em>loads</em>). This reveals that all three available pipes are capable of loading data, while only two of them (don&rsquo;t care which two of them though) can store data. Importantly, each pipe can either load or store data at any given time, but not both simultaneously.</p><p>This structure is described by <a href=https://github.com/llvm/llvm-project/blob/c503758ab6a4eacd3ef671a4a5ccf813995d4456/llvm/lib/Target/X86/X86ScheduleZnver3.td#L368>the following code</a> in Zen3&rsquo;s scheduling model:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 1</span><span>def <span style=color:#89dceb>Zn3LSU</span> : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>3</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 2</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 3</span><span>let Super <span style=color:#89dceb;font-weight:700>=</span> Zn3LSU in
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 4</span><span>def <span style=color:#89dceb>Zn3Load</span> : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>3</span><span style=color:#89dceb;font-weight:700>&gt;</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 5</span><span>  ...
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 6</span><span>}
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 7</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 8</span><span>let Super <span style=color:#89dceb;font-weight:700>=</span> Zn3LSU in
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 9</span><span>def <span style=color:#89dceb>Zn3Store</span> : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>2</span><span style=color:#89dceb;font-weight:700>&gt;</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">10</span><span>  ...
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">11</span><span>}</span></span></code></pre></div><p><code>Zn3Load</code> and <code>Zn3Store</code> are processor resources representing the load and store pipes, respectively. Both of them designate <code>Zn3LSU</code> &ndash; which represents the <em>entire</em> LSU &ndash; as their <strong>super resource</strong> via the <code>Super</code> field.</p><p>By designating <code>Zn3LSU</code> as their super resource, both <code>Zn3Load</code> and <code>Zn3Store</code> are essentially representing a subset of all three pipes from <code>Zn3LSU</code> &ndash; 2 pipes for <code>Zn3Store</code> and 3 for <code>Zn3Load</code>, coinciding with what we saw from Zen3&rsquo;s microarchitecture diagram earlier.
Put it differently, a unit from <code>Zn3LSU</code> can either be <em>allocated</em> as a load or a store pipe, while no more than two store pipes are allowed to exist at any given time.</p><p>LLVM implements super resource in a really similar way to how it implements <code>ProcResGroup</code> &ndash; by <em>expanding</em> <code>ProcResource</code> that has super resources. Let me explain this using the snippet below which shows some <code>Zn3Load</code> and <code>Zn3Store</code> usages.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 1</span><span>def <span style=color:#89dceb>Zn3LSU</span> : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>3</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 2</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 3</span><span>let Super <span style=color:#89dceb;font-weight:700>=</span> Zn3LSU in
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 4</span><span>def <span style=color:#89dceb>Zn3Load</span> : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>3</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 5</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 6</span><span>let Super <span style=color:#89dceb;font-weight:700>=</span> Zn3LSU in
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 7</span><span>def <span style=color:#89dceb>Zn3Store</span> : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>2</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 8</span><span>...
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 9</span><span><span style=color:#6c7086;font-style:italic>// Loads, stores, and moves, not folded with other operations.
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">10</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89dceb>defm</span> : Zn3WriteResInt<span style=color:#89dceb;font-weight:700>&lt;</span>WriteLoad,  [Zn3AGU012, Zn3Load], ...<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">11</span><span><span style=color:#89dceb>defm</span> : Zn3WriteResInt<span style=color:#89dceb;font-weight:700>&lt;</span>WriteStore, [Zn3AGU012, Zn3Store], ...<span style=color:#89dceb;font-weight:700>&gt;</span>;</span></span></code></pre></div><p>In this snippet, <code>WriteLoad</code> &ndash; the <code>SchedWrite</code> for some of the X86 load instructions &ndash; uses <code>Zn3AGU012</code> and <code>Zn3Load</code> while <code>WriteStore</code> &ndash; the <code>SchedRead</code> for some of the X86 store instrutions &ndash; has a similar resource usage of <code>Zn3AGU012</code> and <code>Zn3Store</code>.</p><p>LLVM effectively expands the <code>Zn3Load</code> and <code>Zn3Store</code> usages in these two <code>SchedWrite</code> entries into:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">1</span><span><span style=color:#89dceb>defm</span> : Zn3WriteResInt<span style=color:#89dceb;font-weight:700>&lt;</span>WriteLoad,  [Zn3AGU012, Zn3Load,  Zn3LSU], ...<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">2</span><span><span style=color:#89dceb>defm</span> : Zn3WriteResInt<span style=color:#89dceb;font-weight:700>&lt;</span>WriteStore, [Zn3AGU012, Zn3Store, Zn3LSU], ...<span style=color:#89dceb;font-weight:700>&gt;</span>;</span></span></code></pre></div><p>That&rsquo;s right! Similar to how <code>ProcResGroup</code> <em>implicitly</em> inserts resource usages of overlapping <code>ProcResGroup</code>, LLVM also <em>implicitly</em> inserts resource usages of super resource, <code>Zn3LSU</code>, into the list.</p><p>With the following sequence of X86 load and store instructions:</p><pre tabindex=0><code>movq %r9,    (%rbx)   # store
movq 4(%r8), %rax     # load
movq %r10,   (%rcx)   # store</code></pre><p>They&rsquo;ll have the following resource consumptions upon dispatch (<code>Zn3AGU012</code> is omitted from this table for simplicity):</p><table><thead><tr><th style=text-align:center>instruction</th><th style=text-align:center>Zn3Load</th><th style=text-align:center>Zn3Store</th><th style=text-align:center>Zn3LSU</th></tr></thead><tbody><tr><td style=text-align:center>movq %r9, (%rbx)</td><td style=text-align:center>0 / 3</td><td style=text-align:center>1 / 2</td><td style=text-align:center>1 / 3</td></tr><tr><td style=text-align:center>movq 4(%r8), %rax</td><td style=text-align:center>1 / 3</td><td style=text-align:center>1 / 2</td><td style=text-align:center>2 / 3</td></tr><tr><td style=text-align:center>movq %r10, (%rcx)</td><td style=text-align:center>1 / 3</td><td style=text-align:center>2 / 2</td><td style=text-align:center>3 / 3</td></tr></tbody></table><p>Whenever a store (e.g. <code>movq %r9, (%rbx)</code>) is being dispatched, it increases the counters of both <code>Zn3Store</code> and <code>Zn3LSU</code>. Similarly, a load instruction increases both <code>Zn3Load</code> and <code>Zn3LSU</code> counters.</p><p>Let&rsquo;s use the following consecutive store instructions to show how we throttle the numebr of store pipes to 2:</p><pre tabindex=0><code>movq %r9,  (%rbx)   # store
movq %rax, (%r8)    # store
movq %r10, (%rcx)   # store</code></pre><p>This snippet produces the following resource consumption table:</p><table><thead><tr><th style=text-align:center>instruction</th><th style=text-align:center>Zn3Load</th><th style=text-align:center>Zn3Store</th><th style=text-align:center>Zn3LSU</th></tr></thead><tbody><tr><td style=text-align:center>movq %r9, (%rbx)</td><td style=text-align:center>0 / 3</td><td style=text-align:center>1 / 2</td><td style=text-align:center>1 / 3</td></tr><tr><td style=text-align:center>movq %rax, (%r8)</td><td style=text-align:center>0 / 3</td><td style=text-align:center>2 / 2</td><td style=text-align:center>2 / 3</td></tr><tr><td style=text-align:center>movq %r10, (%rcx)</td><td style=text-align:center>0 / 3</td><td style=text-align:center>FAIL TO CONSUME</td><td style=text-align:center>3 / 3</td></tr></tbody></table><p>The last instruction fails to consume <code>Zn3Store</code>, because it only has a total of 2 units.
In other words, the last instruction in this case is throttled by <code>Zn3Store</code>, despite the fact that there are enought number of LSU pipes.</p><p>And that, is how Zen3 uses super reousrce to set a cap on the number of store pipes in its scheduling model.</p><h3 id=procresgroup-vs-super-resource>ProcResGroup v.s. Super resource</h3><p>So far, we have learned how to use <code>ProcResGroup</code> and super resource. Naturally we want to ask: what are their actual differences and, more importantly, <strong>when</strong> should I use them?</p><p>Conceptually, both super resource and <code>ProcResGroup</code> provide a way to reference a subset of a larger collection of hardware units. Super resource creates a &ldquo;slice&rdquo; of an existing <code>ProcResource</code>; <code>ProcResGroup</code> approaches this from an opposite direction: it combines multiple smaller <code>ProcResource</code> into a larger set, so that we can either reference to the larger set or the original individual resource.</p><p>The main difference between them comes up when execution pipes have certain kinds of <em>partially</em> overlapping capabilities, like this:</p><div style=text-align:center><picture><source srcset=/images/llvm-sched-model-partial-res-overlap.dark.svg media="(prefers-color-scheme: dark)"><img src=/images/llvm-sched-model-partial-res-overlap.light.svg></picture></div><p>First, let&rsquo;s (try to) describe this model with super resource in the following way:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 1</span><span><span style=color:#6c7086;font-style:italic>// Note: this is the WRONG approach
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 2</span><span><span style=color:#6c7086;font-style:italic></span>def <span style=color:#89dceb>IEX</span> : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>3</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 3</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 4</span><span>let Super <span style=color:#89dceb;font-weight:700>=</span> IEX in {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 5</span><span>  def <span style=color:#89dceb>IntegerArith</span> : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>2</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 6</span><span>  def <span style=color:#89dceb>IntegerMul</span>   : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>2</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 7</span><span>  def <span style=color:#89dceb>IntegerDiv</span>   : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>1</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 8</span><span>}
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 9</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">10</span><span><span style=color:#6c7086;font-style:italic>// Simple arithmetics, like ADD
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">11</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteIALU,   [IntegerArith]<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">12</span><span><span style=color:#6c7086;font-style:italic>// Multiplication
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">13</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteIMul,   [IntegerMul]<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">14</span><span><span style=color:#6c7086;font-style:italic>// Division
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">15</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteIDiv,   [IntegerDiv]<span style=color:#89dceb;font-weight:700>&gt;</span>;</span></span></code></pre></div><p>In hindsight, this model looks correct: two out of three pipes can be allocated to MUL or ALU, while only a single pipe can be used for divisions. But things start to get off the track when we run the following RISC-V snippet throught this model.</p><pre tabindex=0><code>mul a1, a1, a2
mul t4, t4, t5
div s0, s0, t0</code></pre><p>First, let&rsquo;s expand those <code>WriteRes</code> entries:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">1</span><span><span style=color:#6c7086;font-style:italic>// Simple arithmetics, like ADD
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">2</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteIALU,   [IntegerArith, IEX]<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">3</span><span><span style=color:#6c7086;font-style:italic>// Multiplication
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">4</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteIMul,   [IntegerMul, IEX]<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">5</span><span><span style=color:#6c7086;font-style:italic>// Division
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">6</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteIDiv,   [IntegerDiv, IEX]<span style=color:#89dceb;font-weight:700>&gt;</span>;</span></span></code></pre></div><p><code>IntegerArith</code>, <code>IntegerMul</code>, and <code>IntegerDiv</code> all have <code>IEX</code> as its super resource, which is implicitly inserted into the list of resource usages in all three entries.</p><p>With this expansion, we can pan out the (plausibly correct) resource consumption table:</p><table><thead><tr><th style=text-align:center>instruction</th><th style=text-align:center>IntegerArith</th><th style=text-align:center>IntegerMul</th><th style=text-align:center>IntegerDiv</th><th style=text-align:center>IEX</th></tr></thead><tbody><tr><td style=text-align:center>mul a1, a1, a2</td><td style=text-align:center>0 / 2</td><td style=text-align:center>1 / 2</td><td style=text-align:center>0 / 1</td><td style=text-align:center>1 / 3</td></tr><tr><td style=text-align:center>mul t4, t4, t5</td><td style=text-align:center>0 / 2</td><td style=text-align:center>2 / 2</td><td style=text-align:center>0 / 1</td><td style=text-align:center>2 / 3</td></tr><tr><td style=text-align:center>div s0, s0, t0</td><td style=text-align:center>0 / 2</td><td style=text-align:center>2 / 2</td><td style=text-align:center>1 / 1</td><td style=text-align:center>3 / 3</td></tr></tbody></table><p>Again, each instruction gets the resources they demanded and everything looks correct &ndash; until you realize that if both <code>IEX1</code> <strong>and</strong> <code>IEX2</code>, the multiplication-capable pipes, have already been consumed, how can the last instruction be dispatched to <code>IEX1</code>, the <em>only</em> pipe that is capable of doing division?</p><p>Now, you might try to fix this by assinging a different super resource to <code>IntegerDiv</code>, let&rsquo;s say <code>IntegerMul</code>:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">1</span><span><span style=color:#6c7086;font-style:italic>// ????
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">2</span><span><span style=color:#6c7086;font-style:italic></span>let Super <span style=color:#89dceb;font-weight:700>=</span> IntegerMul in
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">3</span><span>def <span style=color:#89dceb>IntegerDiv</span>   : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>1</span><span style=color:#89dceb;font-weight:700>&gt;</span>;</span></span></code></pre></div><p>But then we will run into the same problem if we have the following RISC-V snippet, in which <code>add</code> instructions use <code>IntegerALU</code>:</p><pre tabindex=0><code>add a1, a1, a2
add t4, t4, t5
div s0, s0, t0</code></pre><p>Because the first two <code>add</code> instructions will already consume both <code>IEX0</code> and <code>IEX1</code> before division tries to grab <code>IEX1</code> that is no longer available.</p><p>The root cause for the problem we have here is that we cannot declare both <code>IntegerMul</code> <em>and</em> <code>IntegerALU</code> as the super resource of <code>IntegerDiv</code>. Super resource is only effective if you can organize the <code>ProcResource</code> hierarchy into a <strong>tree</strong>.</p><p>Take the processor model we used at the beginning of this post as the example, we can easily organize their processor resources into a tree as shown in the figure below.</p><div style=text-align:center><picture><source srcset=/images/llvm-sched-model-hierarchy-tree.dark.svg media="(prefers-color-scheme: dark)"><img src=/images/llvm-sched-model-hierarchy-tree.light.svg><figcaption>Left: processor model. Right: organized their hierarchy into a tree</figcaption></picture></div><p>On the other hand, the processor model we saw in this section can only be expressed with a <strong>DAG</strong>:</p><div style=text-align:center><picture><source srcset=/images/llvm-sched-model-partial-res-overlap-dag.dark.svg media="(prefers-color-scheme: dark)"><img src=/images/llvm-sched-model-partial-res-overlap-dag.light.svg><figcaption>Left: processor model. Right: organized their hierarchy into a DAG</figcaption></picture></div><p>Of course, we can easily describe this model with DAG structure using <code>ProcResGroup</code>:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 1</span><span>def <span style=color:#89dceb>IEX0</span> : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>1</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 2</span><span>def <span style=color:#89dceb>IEX1</span> : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>1</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 3</span><span>def <span style=color:#89dceb>IEX2</span> : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>1</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 4</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 5</span><span>def <span style=color:#89dceb>IntegerArith</span> : ProcResGroup<span style=color:#89dceb;font-weight:700>&lt;</span>[IEX0, IEX1]<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 6</span><span>def <span style=color:#89dceb>IntegerMul</span>   : ProcResGroup<span style=color:#89dceb;font-weight:700>&lt;</span>[IEX1, IEX2]<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 7</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 8</span><span><span style=color:#6c7086;font-style:italic>// Simple arithmetics, like ADD
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 9</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteIALU,   [IntegerArith]<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">10</span><span><span style=color:#6c7086;font-style:italic>// Multiplication
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">11</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteIMul,   [IntegerMul]<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">12</span><span><span style=color:#6c7086;font-style:italic>// Division
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">13</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteIDiv,   [IEX1]<span style=color:#89dceb;font-weight:700>&gt;</span>;</span></span></code></pre></div><p>After expansion, we effectively have the following <code>WriteRes</code> entries:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">1</span><span><span style=color:#6c7086;font-style:italic>// Simple arithmetics, like ADD
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">2</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteIALU,   [IntegerArith]<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">3</span><span><span style=color:#6c7086;font-style:italic>// Multiplication
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">4</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteIMul,   [IntegerMul]<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">5</span><span><span style=color:#6c7086;font-style:italic>// Division
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">6</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89dceb>def</span> : WriteRes<span style=color:#89dceb;font-weight:700>&lt;</span>WriteIDiv,   [IEX1, IntegerArith, IntegerMul]<span style=color:#89dceb;font-weight:700>&gt;</span>;</span></span></code></pre></div><p>Now <code>WriteIDiv</code> consumes not just <code>IEX1</code> but also <code>IntegerArith</code> and <code>IntegerMul</code> &ndash; the <em>predecessors</em> of the division resource in the DAG we just saw.</p><p>If we run this model over one of the earlier snippets:</p><table><thead><tr><th style=text-align:center>instruction</th><th style=text-align:center>IntegerArith</th><th style=text-align:center>IntegerMul</th><th style=text-align:center>IEX1</th></tr></thead><tbody><tr><td style=text-align:center>mul a1, a1, a2</td><td style=text-align:center>0 / 2</td><td style=text-align:center>1 / 2</td><td style=text-align:center>0 / 1</td></tr><tr><td style=text-align:center>mul t4, t4, t5</td><td style=text-align:center>0 / 2</td><td style=text-align:center>2 / 2</td><td style=text-align:center>0 / 1</td></tr><tr><td style=text-align:center>div s0, s0, t0</td><td style=text-align:center>1 / 2</td><td style=text-align:center>FAIL TO CONSUME</td><td style=text-align:center>1 / 1</td></tr></tbody></table><p>The division instruction is unable to be dispatched, because it failed to consume the <code>IntegerMul</code> resource &ndash; and this behavior is something we expect.</p><p>I hope you&rsquo;re now convinced that <code>ProcResGroup</code> is more flexible and more generic than super resource, because it can express models with either tree or non-tree structures. This comes unsurprised as <code>ProcResGroup</code> was actually <a href=https://github.com/llvm/llvm-project/commit/4e67cba8a65bba60e60f48083269917b39b4e3de>invented</a> <em>later</em> than super resource.</p><p>That said, super resource might come handy when we only care about the number of proceesor units and referencing the exact pipes is less important. For example, in an extreme situation where there are a total of <em>12</em> execution pipes in a model, instead of spelling out all processor resources like this<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">1</span><span>def <span style=color:#89dceb>IEX0</span>  : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>1</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">2</span><span>def <span style=color:#89dceb>IEX1</span>  : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>1</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">3</span><span>...
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">4</span><span>def <span style=color:#89dceb>IEX11</span> : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>1</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">5</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">6</span><span><span style=color:#6c7086;font-style:italic>// I make up these groupings, the point is that it&#39;s
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">7</span><span><span style=color:#6c7086;font-style:italic>// quite cumbersome to referece every IEX pipes they use.
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">8</span><span><span style=color:#6c7086;font-style:italic></span>def <span style=color:#89dceb>IntegerArith</span> : ProcResGroup<span style=color:#89dceb;font-weight:700>&lt;</span>[IEX0, IEX1, ...]<span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">9</span><span>def <span style=color:#89dceb>IntegerMul</span>   : ProcResGroup<span style=color:#89dceb;font-weight:700>&lt;</span>[IEX6, IEX8, ...]<span style=color:#89dceb;font-weight:700>&gt;</span>;</span></span></code></pre></div><p>It&rsquo;s certainly easier and more concise to write:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">1</span><span>def <span style=color:#89dceb>IEX</span> : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>12</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">2</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">3</span><span>let Super <span style=color:#89dceb;font-weight:700>=</span> IEX in {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">4</span><span>  def <span style=color:#89dceb>IntegerArith</span> : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>12</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">5</span><span>  def <span style=color:#89dceb>IntegerMul</span>   : ProcResource<span style=color:#89dceb;font-weight:700>&lt;</span><span style=color:#fab387>6</span><span style=color:#89dceb;font-weight:700>&gt;</span>;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">6</span><span>}</span></span></code></pre></div><h3 id=summary>Summary</h3><p>To conclude, in this post we discussed several options to express processor resources with hierarchy structures. Notably, <code>ProcResGroup</code> and super resource. The takeaway is that <code>ProcResGroup</code> is generally more flexible and versitile than the other options, but can be quite verbose in some cases, in which super resource or even jsut plain <code>ProcResource</code> with multiple units is more desirable.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>The actual dispatching algorithm in real processors is much more complicated, but let&rsquo;s just assume it looks for available pipes without any specific order.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Again, using a processor with issue width of 6&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Even we can simplify it with <code>foreach</code> and some other TableGen magics, I&rsquo;m sure it&rsquo;s still more verbose than using super resource.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></content><p><a href=/blog/llvm/>#llvm</a>&nbsp;&nbsp;
<a href=/blog/compiler-instruction-scheduling/>#compiler-instruction-scheduling</a>&nbsp;&nbsp;</p></main><footer><span>© 2024 Min-Yih Hsu</span>
<span>|
Made with
<a href=https://github.com/maolonglong/hugo-simple/>Hugo ʕ•ᴥ•ʔ Simple</a></span></footer></body></html>