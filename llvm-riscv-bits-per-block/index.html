<!doctype html><html lang=en><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>When LLVM scalable vector meets RISC-V&nbsp;|&nbsp;Min Hsu's Homepage</title>
<meta name=title content="When LLVM scalable vector meets RISC-V"><meta name=description content='And a mistery constant called "RVVBitsPerBlock"'><meta name=keywords content="llvm,riscv,"><meta name=author content="Min-Yih Hsu"><meta property="og:title" content="When LLVM scalable vector meets RISC-V"><meta property="og:description" content='And a mistery constant called "RVVBitsPerBlock"'><meta property="og:type" content="article"><meta property="og:url" content="https://myhsu.xyz/llvm-riscv-bits-per-block/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2024-10-05T00:00:00+00:00"><meta property="article:modified_time" content="2024-10-05T00:00:00+00:00"><meta property="og:site_name" content="Min Hsu's Homepage"><meta name=twitter:card content="summary"><meta name=twitter:title content="When LLVM scalable vector meets RISC-V"><meta name=twitter:description content='And a mistery constant called "RVVBitsPerBlock"'><meta itemprop=name content="When LLVM scalable vector meets RISC-V"><meta itemprop=description content='And a mistery constant called "RVVBitsPerBlock"'><meta itemprop=datePublished content="2024-10-05T00:00:00+00:00"><meta itemprop=dateModified content="2024-10-05T00:00:00+00:00"><meta itemprop=wordCount content="1668"><meta itemprop=keywords content="llvm,riscv,"><meta name=referrer content="no-referrer-when-downgrade"><link href=/simple.min.css rel=stylesheet><link href=/style.min.css rel=stylesheet></head><body><header><nav><a href=/>Home</a>
<a href=/publications/>Publications</a>
<a href=/blog/>Blog</a>
<a href=https://github.com/mshockwave>GitHub</a>
<a href=https://www.linkedin.com/in/bekketmcclane/>LinkedIn</a>
<a href=/index.xml><svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 448 512"><path d="M0 64C0 46.3 14.3 32 32 32c229.8.0 416 186.2 416 416 0 17.7-14.3 32-32 32s-32-14.3-32-32C384 253.6 226.4 96 32 96 14.3 96 0 81.7.0 64zM0 416a64 64 0 11128 0A64 64 0 110 416zM32 160c159.1.0 288 128.9 288 288 0 17.7-14.3 32-32 32s-32-14.3-32-32c0-123.7-100.3-224-224-224-17.7.0-32-14.3-32-32s14.3-32 32-32z"/></svg>
RSS</a></nav><h1>When LLVM scalable vector meets RISC-V</h1><p>And a mistery constant called "RVVBitsPerBlock"</p></header><main><p><i><time datetime=2024-10-05 pubdate>2024-10-05</time></i></p><content><p>There is a <a href=https://llvm.org/docs/RISCV/RISCVVectorExtension.html>nice page</a> about how LLVM handles RISC-V Vector Extension (RVV). It primarily covers how the RISC-V backend lowers vector types and vector operations. Right <a href=https://llvm.org/docs/RISCV/RISCVVectorExtension.html#mapping-to-llvm-ir-types>at the beginning of the page</a> lies this table:</p><figure style=text-align:center><img src=/images/llvm-rvv-ir-types.png></figure><p>It shows the LLVM IR types we use to represent RVV&rsquo;s <em>dynamically</em> sized vectors: each row is an element type, while each column is a <strong>LMUL</strong> &ndash; the register grouping factor, or &ldquo;how many vector registers should we slap together and treat it as a single <em>logical</em> vector register&rdquo;.</p><p>For instance, when LMUL = 4, each vector instruction effectively operates on a (gigantic) logical vector register that is four-time the size of a normal vector register. Under this LMUL setting, a RVV vector of 64-bit integer (i.e. <code>i64</code>) is represented by IR type <code>&lt;vscale x 4 x i64></code> according to the table.</p><p>Both LMUL and the element type can be changed at any point during the runtime, hence the dynamically sized vectors.</p><p>The <code>&lt;vscale x 4 x i64></code> is a <strong>scalable vector type</strong> in LLVM. It looks similar to a normal (fixed) vector type like <code>&lt;4 x i64></code> &ndash; a vector of four 64-bit integers &ndash; but the &ldquo;vscale&rdquo; keyword gives it the ability to scale the &ldquo;base&rdquo; vector type &ndash; namely, the <code>4 x i64</code> part, where 4 here is the <u>minimum number of elements</u> &ndash; by a certain factor, vscale, that is only known during runtime. So if vscale equals to 2 during runtime, we have an equivalent vector of <code>&lt;8 x i64></code>; <code>&lt;16 x i64></code> when vscale is 4. Simple, right?</p><p>Well&mldr;it looks simple until you squint a little harder at the table we just showed and start wonder: <em>how</em> exactly does RVV LMUL map to different scalable vector IR types? how do we calculate the minimum number of elements?</p><p>Using LMUL = 4 again as an example, but this time we want to use <code>i32</code> as the element type. Intuitively, we would have thought the corresponding scalable vector type to be <code>&lt;vscale x 4 x i32></code> because the minimum number of elements is equal to LMUL, right? &ndash; except it is not, it&rsquo;s actually <code>&lt;vscale x 8 x i32></code>.</p><p>To find the answer, we navigate to a line sitting just above the table in the same page:</p><blockquote><p>&mldr;vscale is defined as VLEN/64 (see RISCV::RVVBitsPerBlock).</p></blockquote><p>It suggests that we can calculate the minimum number of scalable vector elements for a RVV type using <code>RISCV::RVVBitsPerBlock</code>, a magic constant that is <a href=https://github.com/llvm/llvm-project/blob/bf895c714e1f8a51c1e565a75acf60bf7197be51/llvm/include/llvm/TargetParser/RISCVTargetParser.h#L36>set to 64</a>.
The code comment for <code>RISCV::RVVBitsPerBlock</code> doens&rsquo;t explain a lot, nor is clear what &ldquo;block&rdquo; here means.</p><p>In this short post, I&rsquo;m going to explain how the table is created and the actual purpose of this mistery <code>RISCV::RVVBitsPerBlock</code> constant.</p><h3 id=arm-sve----the-origin-of-scalable-vector-types>ARM SVE &ndash; the origin of scalable vector types</h3><p>I know it&rsquo;s weird to start a RISC-V blog post with ARM, but I think it&rsquo;s imperative to understand the origin of scalable vector types in LLVM first.</p><p>ARM introduced SVE (Scalable Vector Extension) about 8 years ago. SVE allows vector registers to scale their size by a certain runtime factor, <code>LEN</code>. The figure below<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> shows the structure of vector registers in SVE.</p><div style=text-align:center><picture><source srcset=/images/arm-sve.dark.svg media="(prefers-color-scheme: dark)"><img src=/images/arm-sve.light.svg><figcaption>Scalable vector registers in ARM SVE</figcaption></picture></div><p>When <code>LEN</code> is set to 3, each vector registers <code>Z0</code> ~ <code>Z31</code> has a size of 512 bits (128 * 3 + 128).</p><p>Sounds familiar, right? That&rsquo;s because the scalable vector type in LLVM we just talked about was introduced by ARM folks for SVE, and it&rsquo;s using the exact same principle.</p><p>In the most basic setting, the scalable vector type for a SVE vector has minimum number of elements equal to 128 divided by element size, like <code>&lt;vscale x 4 x i32></code> or <code>&lt;vscale x 2 x i64></code>. And during runtime, vscale is equal to <code>LEN + 1</code>.</p><p>If we think of a single SVE vector register being multiple 128-bit vector registers slapped together &ndash; which I believe it is indeed what happens in hardware &ndash; the runtime factor (i.e. <code>LEN</code>) dictates the <em>number</em> of those fixed-size, 128-bit registers.</p><p>Now we learned that LLVM&rsquo;s scalable vector type is basically a 1:1 mapping to ARM SVE vectors, let&rsquo;s see how well (or bad) it maps to RISC-V vectors.</p><h3 id=scalable-vector-types-meet-rvv>Scalable vector types meet RVV</h3><p>In RVV, each vector register, <code>v0</code> ~ <code>v31</code>, has a size of <code>VLEN</code> bits. <code>VLEN</code> is a hardware-defined constant. Though each RISC-V processor has its own fixed-value <code>VLEN</code>, the software doesn&rsquo;t know it during compile time &ndash; assuming you&rsquo;re building a portable binary.</p><p>As introduced earlier in the post, RVV instructions operate on logical vector register, which is a group of LMUL actual vector registers, as depicted by the following figure.</p><div style=text-align:center><picture><source srcset=/images/rvv-registers.dark.svg media="(prefers-color-scheme: dark)"><img src=/images/rvv-registers.light.svg><figcaption>RISC-V vector registers</figcaption></picture></div><p>To update the current LMUL and element type &ndash; which is also known as <strong>SEW</strong> (Selected Element Width) &ndash; during runtime, we can use instructions like <code>vsetvl</code> and <code>vsetvli</code>.</p><p>For instance, <code>vsetvl rd, rs1, rs2</code> updates the current LMUL and SEW settings according to the (runtime) value stored in scalar register <code>rs2</code>. This LMUL + SEW combination &ndash; part of a RVV setting called <strong>vtype</strong> &ndash; will continue to hold until another <code>vsetvl</code>-family instruction change the vtype.</p><p>Here is the catch: compilers do NOT generate <code>vsetvl</code> in like 99% of the cases.</p><p>Instead, we use one of its siblings, <code>vsetvli</code>, which encodes the desired vtype with <em>immediate value</em> operands. For instance, <code>vsetvli x2, x0, e32, m4</code> sets the new LMUL into 4 because of <code>m4</code>, an immediate value, and the new SEW to be 32-bit wide because of <code>e32</code>, also an immediate value.</p><p>With <code>vsetvli</code>, we can actually know the exact LMUL of a certain region of code <em>ahead of time</em>. For example, the following snippet uses different vtype settings in three different regions, but we&rsquo;re able to statically determine the exact LMUL (and SEW) values in each region.</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 1</span><span><span style=color:#89b4fa>vsetvli</span> <span style=color:#f9e2af>t0</span>, <span style=color:#f9e2af>zero</span>, <span style=color:#f9e2af>e32</span>, <span style=color:#f9e2af>m2</span>, <span style=color:#f9e2af>ta</span>, <span style=color:#f9e2af>ma</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 2</span><span><span style=color:#6c7086;font-style:italic># === operate on LMUL=2 &amp; SEW of 32 bits ====
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 3</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89b4fa>vadd.vv</span> <span style=color:#f9e2af>v2</span>, <span style=color:#f9e2af>v2</span>, <span style=color:#f9e2af>v4</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 4</span><span><span style=color:#89b4fa>vadd.vv</span> <span style=color:#f9e2af>v2</span>, <span style=color:#f9e2af>v2</span>, <span style=color:#f9e2af>v6</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 5</span><span><span style=color:#6c7086;font-style:italic># ===========================================
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 6</span><span><span style=color:#6c7086;font-style:italic></span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 7</span><span><span style=color:#89b4fa>vsetvli</span> <span style=color:#f9e2af>t0</span>, <span style=color:#f9e2af>zero</span>, <span style=color:#f9e2af>e32</span>, <span style=color:#f9e2af>m4</span>, <span style=color:#f9e2af>ta</span>, <span style=color:#f9e2af>ma</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 8</span><span><span style=color:#6c7086;font-style:italic># === operate on LMUL=4 &amp; SEW of 32 bits ====
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c"> 9</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89b4fa>vadd.vv</span> <span style=color:#f9e2af>v0</span>, <span style=color:#f9e2af>v0</span>, <span style=color:#f9e2af>v4</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">10</span><span><span style=color:#89b4fa>vadd.vv</span> <span style=color:#f9e2af>v0</span>, <span style=color:#f9e2af>v0</span>, <span style=color:#f9e2af>v8</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">11</span><span><span style=color:#6c7086;font-style:italic># ===========================================
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">12</span><span><span style=color:#6c7086;font-style:italic></span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">13</span><span><span style=color:#89b4fa>vsetvli</span> <span style=color:#f9e2af>t0</span>, <span style=color:#f9e2af>zero</span>, <span style=color:#f9e2af>e64</span>, <span style=color:#f9e2af>m4</span>, <span style=color:#f9e2af>ta</span>, <span style=color:#f9e2af>ma</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">14</span><span><span style=color:#6c7086;font-style:italic># === operate on LMUL=4 &amp; SEW of 64 bits ====
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">15</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89b4fa>vadd.vv</span> <span style=color:#f9e2af>v0</span>, <span style=color:#f9e2af>v0</span>, <span style=color:#f9e2af>v4</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">16</span><span><span style=color:#89b4fa>vadd.vv</span> <span style=color:#f9e2af>v0</span>, <span style=color:#f9e2af>v0</span>, <span style=color:#f9e2af>v8</span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">17</span><span><span style=color:#6c7086;font-style:italic># ===========================================
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">18</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#89b4fa>ret</span></span></span></code></pre></div><p>The bottom line is that in most cases, LMUL is considered to be &ldquo;semi-dynamic&rdquo; &ndash; it might change during runtime, but in a more <em>deterministic</em> way.</p><p>And that is one of the reasons why RISC-V backend assigns each LMUL (and SEW) a unique scalable vector type &ndash; because it is possible to determine it during compile time. In comparison, ARM SVE folds all the dynamic bits into a single parameter, vscale.</p><p>But now a new problem emerges: <code>VLEN</code> is unknown during compile time, because different RISC-V processors might have different <code>VLEN</code> values. Without knowing the exact value of <code>VLEN</code> we&rsquo;re unable to know the number of elements in a single vector register, which is different from SVE&rsquo;s case because the latter effectively has a &ldquo;base&rdquo; vector register of 128 bits.</p><p>Let&rsquo;s try to solve this problem with one of our (incorrect) intuitions mentioned earlier: use LMUL &ndash; the &ldquo;known&rdquo; value &ndash; as the minimum number of elements in a scalable vector type, and fold every unknowns &ndash; including <code>VLEN</code> &ndash; into vscale. So LMUL=4 + SEW=32 becomes <code>&lt;vscale x 4 x i32></code> or <code>&lt;vscale x 4 x f32></code>.</p><p>To illustrate this solution, let&rsquo;s rearrange our RVV LMUL figure earlier so that the unknown part, <code>VLEN</code>, is put along the horizontal axis, while individual vector registers are arranged vertically with the respective LMUL quantity.</p><div style=text-align:center><picture><source srcset=/images/rvv-sve-registers-naive.dark.svg media="(prefers-color-scheme: dark)"><img src=/images/rvv-sve-registers-naive.light.svg><figcaption>A naive way to map RVV vectors to scalable vector types</figcaption></picture></div><p>In this solution, RVV&rsquo;s vscale value is equal to the number of (vertical) dotted boxes, <code>VLEN / SEW</code>. This means that we might have different vscale at different code regions since SEW might change (recall the snippet shown above) &ndash; and that, causes lots of inconveniences.</p><p>The value of vscale is essential to estimating the number of vector elements, which directly relates to many things like <em>vectorization factors</em> (i.e. how many items can we process in a single iteration of a vectorized loop). Having a more predictable range of vscale is always preferrable to the optimizers.</p><p>To have a vscale value that doesn&rsquo;t depend on <code>SEW</code>, there is a simple trick: create a fake, <em>fixed-size</em> &ldquo;base vector&rdquo; similar to what SVE has.</p><div style=text-align:center><picture><source srcset=/images/rvv-register-final.dark.svg media="(prefers-color-scheme: dark)"><img src=/images/rvv-register-final.light.svg></picture></div><p>The figure above used a fake base vector of 64 bits, which contains 2 elements in it when SEW=32. Combining with LMUL=4, we get eight 32-bit elements in a single dotted box. Again, vscale value is equal to the number of dotted boxes, but this time, we can easily evaluate it with <code>VLEN / 64</code> &ndash; vscale no longer depends on <code>SEW</code>.</p><p>The size of the fake base vector, 64 bits in this example, is <code>RISCV::RISCVBitsPerBlock</code>. To put it differently, in RISC-V backend, the vscale value is always equal to <code>VLEN / RISCV::RISCVBitsPerBlock</code>.</p><p>It sound a little bit like magic where the <code>SEW</code> factor just suddenly disappears from the equation. But what it really does was simply using the <em>least common multiple (LCM)</em> of all the supported SEW (8, 16, 32, and 64 bits) to &ldquo;tile&rdquo; <code>VLEN</code>. The downside of this design is that we can&rsquo;t support 32-bit <code>VLEN</code> out of the box, which is a known limitation in RISC-V LLVM backend. It sounds a little unusal to have such a small vector size of 32 bits, but apparently <code>Zve32*</code> extensions were created to put vectors into embedded devices, in which case a smaller vector sizes makes more sense.</p><p>Granted, it&rsquo;s not really common to use <code>RISCV::RISCVBitsPerBlock</code> directly, but I thought it&rsquo;s fun to know where it came from and why it&rsquo;s created in the first place. And that&rsquo;s all for this short post! Hope you enjoy.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>I redrew <a href="https://developer.arm.com/documentation/102476/0100/SVE-architecture-fundamentals/Scalable-vector-registers-z0-z31?lang=en">this figure</a> from ARM&rsquo;s official document. Because the original figure missed an important component &ndash; it&rsquo;s &ldquo;LEN x 128&rdquo;, not just &ldquo;LEN 128&rdquo;.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></content><p><a href=/blog/llvm/>#llvm</a>&nbsp;&nbsp;
<a href=/blog/riscv/>#riscv</a>&nbsp;&nbsp;</p></main><footer><span>© 2024 Min-Yih Hsu</span>
<span>|
Made with
<a href=https://github.com/maolonglong/hugo-simple/>Hugo ʕ•ᴥ•ʔ Simple</a></span></footer></body></html>