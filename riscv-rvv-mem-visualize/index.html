<!doctype html><html lang=en><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Visualize RISC-V Vector Memory Instructions&nbsp;|&nbsp;Min Hsu's Homepage</title>
<meta name=title content="Visualize RISC-V Vector Memory Instructions"><meta name=description content="RISC-V Vector (RVV) extension has several kinds of load / store instructions which access memory in different ways. Just as the memory access pattern might take a little more time to fully understand, it gets even more tricky when multiplexing with RVV&rsquo;s own concepts like variable element size (SEW), register groups (LMUL), number of elements (VL), masks and mask / tail policies.
Personally I found it easier to memorize them with visualization, hence this (relatively) short post!"><meta name=keywords content="riscv,"><meta name=author content="Min-Yih Hsu"><meta property="og:title" content="Visualize RISC-V Vector Memory Instructions"><meta property="og:description" content="RISC-V Vector (RVV) extension has several kinds of load / store instructions which access memory in different ways. Just as the memory access pattern might take a little more time to fully understand, it gets even more tricky when multiplexing with RVV&rsquo;s own concepts like variable element size (SEW), register groups (LMUL), number of elements (VL), masks and mask / tail policies.
Personally I found it easier to memorize them with visualization, hence this (relatively) short post!"><meta property="og:type" content="article"><meta property="og:url" content="https://myhsu.xyz/riscv-rvv-mem-visualize/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-01-05T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-05T00:00:00+00:00"><meta property="og:site_name" content="Min Hsu's Homepage"><meta name=twitter:card content="summary"><meta name=twitter:title content="Visualize RISC-V Vector Memory Instructions"><meta name=twitter:description content="RISC-V Vector (RVV) extension has several kinds of load / store instructions which access memory in different ways. Just as the memory access pattern might take a little more time to fully understand, it gets even more tricky when multiplexing with RVV&rsquo;s own concepts like variable element size (SEW), register groups (LMUL), number of elements (VL), masks and mask / tail policies.
Personally I found it easier to memorize them with visualization, hence this (relatively) short post!"><meta itemprop=name content="Visualize RISC-V Vector Memory Instructions"><meta itemprop=description content="RISC-V Vector (RVV) extension has several kinds of load / store instructions which access memory in different ways. Just as the memory access pattern might take a little more time to fully understand, it gets even more tricky when multiplexing with RVV&rsquo;s own concepts like variable element size (SEW), register groups (LMUL), number of elements (VL), masks and mask / tail policies.
Personally I found it easier to memorize them with visualization, hence this (relatively) short post!"><meta itemprop=datePublished content="2025-01-05T00:00:00+00:00"><meta itemprop=dateModified content="2025-01-05T00:00:00+00:00"><meta itemprop=wordCount content="1464"><meta itemprop=keywords content="riscv,"><meta name=referrer content="no-referrer-when-downgrade"><link href=/simple.min.css rel=stylesheet><link href=/style.min.css rel=stylesheet></head><body><header><nav><a href=/>Home</a>
<a href=/publications/>Publications</a>
<a href=/blog/>Blog</a>
<a href=https://github.com/mshockwave>GitHub</a>
<a href=https://www.linkedin.com/in/bekketmcclane/>LinkedIn</a>
<a href=/index.xml><svg xmlns="http://www.w3.org/2000/svg" class="icon" viewBox="0 0 448 512"><path d="M0 64C0 46.3 14.3 32 32 32c229.8.0 416 186.2 416 416 0 17.7-14.3 32-32 32s-32-14.3-32-32C384 253.6 226.4 96 32 96 14.3 96 0 81.7.0 64zM0 416a64 64 0 11128 0A64 64 0 110 416zM32 160c159.1.0 288 128.9 288 288 0 17.7-14.3 32-32 32s-32-14.3-32-32c0-123.7-100.3-224-224-224-17.7.0-32-14.3-32-32s14.3-32 32-32z"/></svg>
RSS</a></nav><h1>Visualize RISC-V Vector Memory Instructions</h1></header><main><p><i><time datetime=2025-01-05 pubdate>2025-01-05</time></i></p><content><p>RISC-V Vector (RVV) extension has several kinds of load / store instructions which access memory in different ways. Just as the memory access pattern might take a little more time to fully understand, it gets even more tricky when multiplexing with RVV&rsquo;s own concepts like variable element size (SEW), register groups (LMUL), number of elements (VL), masks and mask / tail policies.</p><p>Personally I found it easier to memorize them with visualization, hence this (relatively) short post!</p><p>The following content is going to put these instructions in two main categories by their memory access patterns: <em>strided</em> and <em>segmented</em> access. Each of them can be further divided into several sub categories.
We also assume <code>VLEN</code> &ndash; the size of a single vector register &ndash; to be 128 bits. And since RVV store instructions work nearly the same way as loads except going to other direction from registers to memory, we&rsquo;re only discussing load instructions here.</p><p>Without further ado, let&rsquo;s get started!</p><h3 id=strided-access>Strided access</h3><p>Strided memory access is meant to read individual elements from the memory into a <em>single</em> vector register group. The sub variants of this mainly differ in how the &ldquo;gap&rdquo; between two in-memory elements is determined (or whether there is a gap at all).</p><h4 id=unit-stride>Unit-stride</h4><p>Consider this snippet:</p><pre tabindex=0><code>vsetvli  zero, zero, e32, m4
vle32.v  v4, (a0)</code></pre><p>We&rsquo;re loading a <em>continuous</em> (meaning, no gap between two elements) chunk of data starting from the memory address pointed by <code>a0</code>.</p><p>This is the diagram for it:</p><div style=text-align:center;min-width:50vw><picture><source srcset=/images/riscv-unit-stride-load.dark.svg media="(prefers-color-scheme: dark)"><img src=/images/riscv-unit-stride-load.light.svg></picture></div><p>Here, I would like to spend some time on an important concept called <strong>effective</strong> LMUL and SEW, or <em>EMUL</em> and <em>EEW</em>, respectively. Normally, we use VSETVL instructions, like <code>vsetvli</code> shown above, to select the current LMUL (register grouping) and SEW (element width) settings.</p><p>But case like the unit stride load we&rsquo;re discussing here uses their <em>own</em> element width setting that is directly encoded into the opcode. And such element width setting, the one they actually use, is called EEW &ndash; effective element width.</p><p>For unit stride load, EEW is placed in the opcode with this format: <code>vle&lt;eew>.v</code>. So regardless of what <code>vsetvli</code> instruction right before it says, <code>vle32.v</code> always loads 32-bit elements from the memory.</p><p>But does that means we can ignore the SEW setting specified in the <code>vsetvli</code> instruction above? It turns out we cannot, because if the SEW (by <code>vsetvli</code>) is different from EEW (by <code>vle32.v</code>), we have to <em>scale</em> the register grouping (LMUL) as well! The scaled register grouping &ndash; effective LMUL or <em>EMUL</em> &ndash; is the one we actually use, and it&rsquo;s calculated by</p><pre tabindex=0><code>EMUL = (EEW / SEW) * LMUL</code></pre><p>To give a concrete example, considered the following snippet:</p><pre tabindex=0><code>vsetvli  zero, zero, e32, m4
vle64.v  v4, (a0)</code></pre><p>EEW (e64) now differs from SEW (e32). Therefore, while it loads 64-bit elements from memory, the register grouping it actually uses (i.e. EMUL) is now 8, because <code>EMUL = (e64 / e32) * 4</code>.</p><p>The idea of scaling LMUL is to make sure <code>VLMAX</code> &ndash; the maximum number of elements we can process, or the maximum <code>VL</code> value &ndash; stays the same.</p><h4 id=strided>Strided</h4><p>For this, we&rsquo;re loading a stream of data in which elements are apart from each other in the memory by a certain distance or, <em>stride</em>.</p><pre tabindex=0><code>li  t0, 8
vsetvli  zero, zero, e32, m4
vlse32.v  v4, (a0), t0</code></pre><p>For instance, the snippet above loads the next element 8 bytes away from the starting address of the current element. Here is how it looks like:</p><br><div style=text-align:center;min-width:45vw><picture><source srcset=/images/riscv-stride-load.dark.svg media="(prefers-color-scheme: dark)"><img src=/images/riscv-stride-load.light.svg></picture></div><p>In this diagram, &ldquo;Stride&rdquo; is equal to 8, which is designated by <code>t0</code> in the original snippet.</p><p>It&rsquo;s worth noting that <code>VL</code> is still describing the total number of elements we want to load, or number of elements in the destination vector register group, rather than the &ldquo;total range&rdquo; of EEW-size elements on the memory. Same logic goes to the mask: it&rsquo;s applying on the vector register group rather on the memory.</p><h4 id=indexed>Indexed</h4><p>What if we don&rsquo;t want a <em>single</em> constant stride, but different &ldquo;strides&rdquo; for each elements?
Allow me to introduce the indexed scheme, where the memory address offset &ndash; or index value &ndash; for each element is specified by yet another vector register group.</p><pre tabindex=0><code>vsetvli  zero, zero, e32, m4
vluxei32.v  v4, (a0), v0</code></pre><p>Here, the register group started with <code>v0</code> contains the offset values (in bytes) for each element it wants to load. This is how it looks:</p><br><div style=text-align:center;min-width:50vw><picture><source srcset=/images/riscv-index-load.dark.svg media="(prefers-color-scheme: dark)"><img src=/images/riscv-index-load.light.svg></picture></div><p>With a new vector register group as indices come into play, indexed load has a slightly different rule regarding EEW and EMUL. The element width encoded in the opcode &ndash; 32 bits in the case of <code>vluxei32</code> &ndash; becomes EEW for the <em>index</em> register group, which consequently uses the scaled register grouping factor as its EMUL.
On the other hand, the data register group now uses SEW and LMUL specified by <code>vsetvli</code> as their element width and register grouping factor!</p><p>As shown in the diagram, these offset values from the index register group are always applied relative to the starting address &ndash; the one pointed by <code>a0</code> &ndash; rather than being relative to the address of the previous element.</p><p>Another thing worth noting is that the instruction we used, <code>vluxei32.v</code>, accesses elements on memory in <em>arbitrary</em> order, just like unit-stride and constant-stride loads. RVV, however, does provide another variant of indexed load, <code>vloxei32.v</code>, that accesses memory in-order.</p><h3 id=segmented-access>Segmented access</h3><p>Rather than dealing with individual in-memory elements, segmented memory access pattern reads a larger chunk of memory &ndash; namely, a segment &ndash; at a time and distributes the content of a segment into <em>multiple</em> vector register groups.</p><p>It is designed for scenarios where there is an array of objects on memory, for instance:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">1</span><span><span style=color:#cba6f7>struct</span> <span style=color:#f9e2af>Point</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">2</span><span>  <span style=color:#f38ba8>uint32_t</span> X;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">3</span><span>  <span style=color:#f38ba8>uint32_t</span> Y;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">4</span><span>};
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">5</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">6</span><span>Point the_array[<span style=color:#fab387>100</span>];</span></span></code></pre></div><p>We want to read <code>the_array</code> from memory <em>and</em> effectively turn it into something like this:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">1</span><span><span style=color:#6c7086;font-style:italic>// Note: this is just a pseudo code.
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">2</span><span><span style=color:#6c7086;font-style:italic></span><span style=color:#cba6f7>struct</span> <span style=color:#f9e2af>NewPoint</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">3</span><span>  <span style=color:#f38ba8>uint32_t</span> X[<span style=color:#fab387>100</span>]; <span style=color:#6c7086;font-style:italic>// A vector register group.
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">4</span><span><span style=color:#6c7086;font-style:italic></span>  <span style=color:#f38ba8>uint32_t</span> Y[<span style=color:#fab387>100</span>]; <span style=color:#6c7086;font-style:italic>// The other vector register group.
</span></span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">5</span><span><span style=color:#6c7086;font-style:italic></span>};
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">6</span><span>
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">7</span><span>NewPoint the_array_new;</span></span></code></pre></div><p>Where we use a vector register group to store all the <code>X</code> values, and use the other vector register group for <code>Y</code>.</p><p>In this case, <code>struct Point</code> is considered a <strong>segment</strong> with two <em>fields</em> (i.e. <code>X</code> and <code>Y</code>). A segment is also known as a &ldquo;sub-array&rdquo;, which means that individual fields in a segment need to have the <em>same</em> data width. Therefore, this is NOT a segment:</p><div class=highlight><pre tabindex=0 style=color:#cdd6f4;background-color:#1e1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">1</span><span><span style=color:#cba6f7>struct</span> <span style=color:#f9e2af>Foo</span> {
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">2</span><span>  <span style=color:#f38ba8>uint16_t</span> A;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">3</span><span>  <span style=color:#f38ba8>uint32_t</span> B;
</span></span><span style=display:flex><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f849c">4</span><span>};</span></span></code></pre></div><p>For the following content, let&rsquo;s use <code>struct Point</code> as the segment.</p><h4 id=unit-stride-segmented>Unit-stride segmented</h4><p>Unit segmented load encodes the number of fields (NF) along with EEW in its opcode: <code>vlseg&lt;NF>e&lt;EEW>.v</code>.</p><p>Take following snippet as an example:</p><pre tabindex=0><code>vsetvli  zero, zero, e32, m4
vlseg2e32.v  v4, (a0)</code></pre><p>It&rsquo;s loading a <em>continuous</em> sequence of two-field segments starting with the memory address pointed by <code>a0</code>. Here is the diagram:</p><br><div style=text-align:center;min-width:60vw><picture><source srcset=/images/riscv-unit-segmented-load.dark.svg media="(prefers-color-scheme: dark)"><img src=/images/riscv-unit-segmented-load.light.svg></picture></div><p>The most unique aspect here is of course how it deals with individual fields in a segment: in principle, values from the same field is store in a single vector register group.</p><p>The destination register group specified in the assembly instruction, <code>v4</code> in this case, tells the register group (i.e. <code>v4</code> ~ <code>v7</code>) for the first field. The next field will be stored in the <em>following</em> register group (i.e. <code>v8</code> ~ <code>v11</code>), and so on and so forth.</p><p>So if we have something like <code>vlseg3e32.v v4, (a0)</code> with EMUL = 2, a total of three vector register groups will be touched: <code>v4</code> ~ <code>v5</code>, <code>v6</code> ~ <code>v7</code>, and <code>v8</code> ~ <code>v9</code>.</p><p>Similar to strided and indexed loads mentioned earlier, <code>VL</code> and mask are applied on each of the (destination) vector register groups, rather than applying on the memory.</p><h4 id=strided-segmented>Strided segmented</h4><p>This is the segmented version of strided load we&rsquo;d seen earlier.</p><pre tabindex=0><code>li  t0, 16
vsetvli  zero, zero, e32, m4
vlsseg2e32.v  v4, (a0), t0</code></pre><br><div style=text-align:center;min-width:50vw><picture><source srcset=/images/riscv-stride-segmented-load.dark.svg media="(prefers-color-scheme: dark)"><img src=/images/riscv-stride-segmented-load.light.svg></picture></div><p>The start address of the next segment is equal to that of the current segment plus stride.</p><h4 id=indexed-segmented>Indexed segmented</h4><p>Finally, indexed segmented is, you guess, the segmented version of indexed load! (duh&mldr;)</p><pre tabindex=0><code>vsetvli  zero, zero, e32, m4
vluxseg2ei32.v  v4, (a0), v0</code></pre><br><div style=text-align:center;min-width:60vw><picture><source srcset=/images/riscv-index-segmented-load.dark.svg media="(prefers-color-scheme: dark)"><img src=/images/riscv-index-segmented-load.light.svg></picture></div><p>Again, the offset values are always relative to the starting address (in this case, value of <code>a0</code>) rather than being relative to the address of the previous segment.</p><p>Similar to indexed load, <code>vluxseg</code> accesses memory in arbitrary order while <code>vloxseg</code> being its ordered variant. The EEW encoded in the opcode is for the index register group while all the data register groups are using SEW and LMUL.</p><hr><p>And that&rsquo;s pretty much it! Once we categorized in this way it&rsquo;s actually not so hard to understand. Segmented access might look daunting at first glance, but once you&rsquo;re familiar with segments, rest of the concepts can just be carried over from their strided access counterparts.</p><h3 id=comments>Comments</h3><p>Feel free to leave comments at <a href=https://github.com/mshockwave/portfolio/discussions/8>https://github.com/mshockwave/portfolio/discussions/8</a></p><p>Any feedback is much appreciated!</p></content><p><a href=/blog/riscv/>#riscv</a>&nbsp;&nbsp;</p></main><footer><span>© 2024 Min-Yih Hsu</span>
<span>|
Made with
<a href=https://github.com/maolonglong/hugo-simple/>Hugo ʕ•ᴥ•ʔ Simple</a></span></footer></body></html>